"""
CryptoLab — Strategy Base Class
All TradingView strategies are translated by implementing IStrategy.
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import Optional, List, Dict, Any
import numpy as np


@dataclass
class Signal:
    """A trading signal generated by a strategy."""
    direction: int          # 1 = LONG, -1 = SHORT
    confidence: float       # 0-100
    entry_price: float
    sl_price: float
    tp_levels: List[float]  = field(default_factory=lambda: [])
    tp_sizes: List[float]   = field(default_factory=lambda: [1.0])
    leverage: float         = 1.0
    be_trigger: float       = 0.0   # Price that activates break-even
    trailing: bool          = False
    trailing_distance: float = 0.0
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class ParamDef:
    """Definition of an optimizable parameter."""
    name: str
    ptype: str              # 'float', 'int', 'bool', 'categorical'
    default: Any
    min_val: Any = None
    max_val: Any = None
    step: Any = None
    options: List[Any] = field(default_factory=list)
    
    def to_dict(self) -> dict:
        return {
            'type': self.ptype,
            'default': self.default,
            'min': self.min_val,
            'max': self.max_val,
            'step': self.step,
            'options': self.options,
        }


class IStrategy(ABC):
    """
    Abstract base class for all trading strategies.
    
    Workflow:
    1. set_params() → configure parameters
    2. calculate_indicators() → compute all indicators (vectorized)
    3. generate_signal() → check for signal at bar i
    """
    
    def __init__(self, params: Dict[str, Any] = None):
        self.params = params or {}
        self._indicators: Dict[str, np.ndarray] = {}
        self._last_signal_bar: int = -999
    
    @abstractmethod
    def name(self) -> str:
        """Strategy name."""
        ...
    
    @abstractmethod
    def parameter_defs(self) -> List[ParamDef]:
        """Return list of optimizable parameters with ranges."""
        ...
    
    @abstractmethod
    def calculate_indicators(self, data: dict) -> dict:
        """
        Calculate all indicators from OHLCV data.
        data: dict with keys 'open', 'high', 'low', 'close', 'volume', 'hl2', 'timestamp'
        Returns: dict of indicator arrays
        """
        ...
    
    @abstractmethod
    def generate_signal(self, indicators: dict, idx: int,
                        data: dict) -> Optional[Signal]:
        """
        Check for signal at bar index idx.
        Returns Signal if conditions met, None otherwise.
        """
        ...
    
    def set_params(self, params: Dict[str, Any]):
        """Update strategy parameters."""
        self.params.update(params)
        self._last_signal_bar = -999
    
    def get_param(self, key: str, default: Any = None) -> Any:
        """Get parameter with fallback to default from ParamDef."""
        if key in self.params:
            return self.params[key]
        for pd in self.parameter_defs():
            if pd.name == key:
                return pd.default
        return default
    
    def default_params(self) -> Dict[str, Any]:
        """Return dict of all parameters with defaults."""
        return {pd.name: pd.default for pd in self.parameter_defs()}
    
    def with_params(self, params: Dict[str, Any]) -> 'IStrategy':
        """Return copy of strategy with new parameters."""
        import copy
        new = copy.deepcopy(self)
        new.set_params(params)
        return new
    
    def on_trade_update(self, trade: dict, data: dict,
                        idx: int) -> Optional[dict]:
        """
        Hook called while a trade is open.
        Can return dict with updated SL/TP for trailing, BE, etc.
        """
        return None
