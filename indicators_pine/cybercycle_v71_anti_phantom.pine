// This Pine Scriptâ„¢ code is subject to the terms of the Mozilla Public License 2.0
// Â© Ehlers Cyber Cycle SIGNALS v7.1 â€” Regime-Aware + Anti-Phantom
//
// Changes from v7.0:
//   ğŸ”´ FIX: GHOST COOLDOWN â€” lastSigBar only updates after persistence passes.
//      Phantom signals that die before threshold are completely ignored.
//   ğŸ”´ FIX: TICK/TIME PERSISTENCE â€” signal must stay true continuously for
//      N seconds or N ticks before activating. Once persistence is reached,
//      the signal locks ON for the rest of the bar (no flickering).
//      Three modes: Time (deterministic), Ticks (simple), Off (v6.2 behavior).
//   ğŸ”´ FIX: ALERTS â€” only fire after persistence, not on phantom ticks.
//
// From v7.0:
//   âœ… [P1] CYCLE AMPLITUDE FILTER â€” suppresses signals when cycle amplitude is too small
//   âœ… [P2] SQUEEZE FILTER (BB inside KC) â€” detects volatility compression = ranging
//   âœ… [P3] ADX FILTER â€” classic trend strength gate
//   âœ… [P4] CYCLE STRENGTH FILTER â€” autocorrelation peak quality from periodogram
//   âœ… [P5] SNR FILTER â€” signal-to-noise ratio of the dominant cycle
//   âœ… All 5 filters are independently toggleable (on/off per filter)
//   âœ… Regime status in info table + background coloring
//   âœ… Confidence system now includes regime bonus/penalty
//
// Carried from v6.2:
//   âœ… Per-Coin Alpha Method + Per-Coin iTrend + Price Labels
//
// References:
// - John Ehlers, "Cybernetic Analysis for Stocks and Futures" (2004)
// - John Ehlers, "Cycle Analytics for Traders" (2013)
// - John Ehlers, "MESA and Trading Market Cycles" (2nd ed, 2001)
// - John Carter, "Mastering the Trade" (TTM Squeeze concept)

//@version=6
indicator("Ehlers CyberCycle v7.1 Anti-Repaint", shorttitle="CC v7.1", overlay=true, max_labels_count=500)


// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                     GLOBAL SETTINGS                             â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

grp_global = "â•â•â•â•â•â• GLOBAL SETTINGS â•â•â•â•â•â•"
srcCyber       = input.source(hl2, "Source", group=grp_global)
signalMode     = input.string("Per Coin", "Confidence Mode",
     options=["Per Coin", "Conservative", "Standard", "Aggressive"], group=grp_global)
string persistMode = input.string("Time", "Persist Mode",
     options=["Time", "Ticks", "Off"], group=grp_global,
     tooltip="Anti-phantom signal filter. A signal must persist continuously before it activates.\n\nâ€¢ Time: signal must stay true for X seconds (recommended â€” deterministic, independent of exchange tick rate).\n\nâ€¢ Ticks: signal must survive X consecutive ticks (simpler but tick rate varies with market activity).\n\nâ€¢ Off: signal activates on the first tick it qualifies (original v6.2 behavior â€” fastest but allows phantoms).")
float persistSec   = input.float(5.0,  "  Persist Seconds",   minval=1.0, maxval=30.0, step=1.0, group=grp_global,
     tooltip="Seconds the signal must stay continuously true.\n5s = good for 1H+ (filters 1-2 tick spikes, still fast entry).\n10s = more conservative.\n2-3s = aggressive, filters only the fastest phantoms.")
int   persistTicks = input.int  (5,    "  Persist Ticks",     minval=2,   maxval=30,             group=grp_global,
     tooltip="Consecutive ticks the signal must stay true.\nNote: tick rate varies with market activity.\n5 ticks = ~50ms during high volume, ~minutes during low volume.\n3 = aggressive, 8-10 = conservative.")


// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                     ALPHA METHOD PARAMETERS                     â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”€â”€â”€ HOMODYNE â”€â”€â”€
grp_hd = "â”€â”€ Homodyne Params â”€â”€"
hdMinPeriod    = input.float(3.0, "Min Period", minval=2, maxval=10, step=1, group=grp_hd)
hdMaxPeriod    = input.float(40.0, "Max Period", minval=15, maxval=80, step=5, group=grp_hd)

// â”€â”€â”€ MAMA â”€â”€â”€
grp_mama = "â”€â”€ MAMA Params â”€â”€"
mamaFastLimit  = input.float(0.5, "Fast Limit (alpha max)", minval=0.2, maxval=0.8, step=0.05, group=grp_mama,
     tooltip="Maximum alpha when phase changes fast.\nHigher = more reactive to moves.\nCrypto: 0.4-0.6")
mamaSlowLimit  = input.float(0.05, "Slow Limit (alpha min)", minval=0.01, maxval=0.2, step=0.01, group=grp_mama,
     tooltip="Minimum alpha during quiet periods.\nLower = smoother during consolidation.\nCrypto: 0.03-0.10")

// â”€â”€â”€ AUTOCORRELATION â”€â”€â”€
grp_ac = "â”€â”€ Autocorrelation Params â”€â”€"
acMinPeriod    = input.int(6, "Min Period", minval=3, maxval=15, group=grp_ac)
acMaxPeriod    = input.int(48, "Max Period", minval=20, maxval=80, group=grp_ac)
acAvgLength    = input.int(3, "Avg Length", minval=1, maxval=5, group=grp_ac,
     tooltip="Averaging cycles for autocorrelation.\nHigher = smoother but slower.")

// â”€â”€â”€ KALMAN â”€â”€â”€
grp_kal = "â”€â”€ Kalman Params â”€â”€"
kalProcessNoise = input.float(0.01, "Process Noise (Q)", minval=0.001, maxval=0.2, step=0.005, group=grp_kal,
     tooltip="State uncertainty. Higher = more responsive.\nCrypto: 0.005-0.05")
kalMeasNoise    = input.float(0.5, "Measurement Noise (R)", minval=0.05, maxval=3.0, step=0.1, group=grp_kal,
     tooltip="Observation noise. Higher = more smoothing.")
kalAlphaFast    = input.float(0.5, "Alpha Fast", minval=0.2, maxval=0.8, step=0.05, group=grp_kal)
kalAlphaSlow    = input.float(0.05, "Alpha Slow", minval=0.01, maxval=0.2, step=0.01, group=grp_kal)
kalSensitivity  = input.float(2.0, "Sensitivity", minval=0.5, maxval=5.0, step=0.5, group=grp_kal,
     tooltip="How aggressively alpha responds to innovation.\nHigher = more reactive to price surprises.")


// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                     PER-COIN CONFIGURATION                      â•‘
// â•‘  Now includes: Alpha Method + iTrend Alpha + Manual Alpha       â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”€â”€â”€ BTC â”€â”€â”€
grp_BTC = "â”€â”€â”€â”€ BTC â”€â”€â”€â”€"
cfg_BTC_alphaM    = input.string("MAMA", "Alpha Method", options=["Homodyne","MAMA","Autocorrelation","Kalman","Manual"], group=grp_BTC,
     tooltip="Alpha estimation method for BTC.\nMAMA recommended for BTC due to its strong cyclical behavior.")
cfg_BTC_manAlpha  = input.float(0.35, "Manual Alpha (if Manual)", minval=0.05, maxval=0.80, step=0.01, group=grp_BTC)
cfg_BTC_iTrendA   = input.float(0.07, "iTrend Alpha", minval=0.01, maxval=0.3, step=0.01, group=grp_BTC,
     tooltip="iTrend smoothing for BTC.\nLower = smoother trend line.\nBTC: 0.05-0.10 recommended.")
cfg_BTC_trigEma   = input.int(14,    "Trigger EMA",       minval=3,   maxval=30,                 group=grp_BTC)
cfg_BTC_minBars   = input.int(24,    "Min Bars Between",  minval=5,   maxval=50,                 group=grp_BTC)
cfg_BTC_conf      = input.float(80,  "Confidence Min %",  minval=30,  maxval=95,  step=5,        group=grp_BTC)
cfg_BTC_volMult   = input.float(2.0, "Volume Multiplier", minval=0.5, maxval=5.0, step=0.1,     group=grp_BTC)
cfg_BTC_ob        = input.float(1.5, "OB Level",          minval=0.3, maxval=3.0, step=0.1,     group=grp_BTC)
cfg_BTC_os        = input.float(-1.5,"OS Level",          minval=-3.0,maxval=-0.3,step=0.1,     group=grp_BTC)
cfg_BTC_aFloor    = input.float(0.0, "Alpha Floor (0=off)",minval=0.0,maxval=0.50,step=0.01,    group=grp_BTC)
cfg_BTC_htf       = input.bool(true, "Use HTF Filter",    group=grp_BTC)
cfg_BTC_trend     = input.bool(true, "Use Trend Filter",  group=grp_BTC)
cfg_BTC_vol       = input.bool(true, "Use Volume Filter", group=grp_BTC)

// â”€â”€â”€ ETH â”€â”€â”€
grp_ETH = "â”€â”€â”€â”€ ETH â”€â”€â”€â”€"
cfg_ETH_alphaM    = input.string("MAMA", "Alpha Method", options=["Homodyne","MAMA","Autocorrelation","Kalman","Manual"], group=grp_ETH,
     tooltip="Alpha estimation method for ETH.\nMAMA or Kalman recommended.")
cfg_ETH_manAlpha  = input.float(0.35, "Manual Alpha (if Manual)", minval=0.05, maxval=0.80, step=0.01, group=grp_ETH)
cfg_ETH_iTrendA   = input.float(0.07, "iTrend Alpha", minval=0.01, maxval=0.3, step=0.01, group=grp_ETH,
     tooltip="iTrend smoothing for ETH.\nETH: 0.05-0.09 recommended.")
cfg_ETH_trigEma   = input.int(12,    "Trigger EMA",       minval=3,   maxval=30,                 group=grp_ETH)
cfg_ETH_minBars   = input.int(20,    "Min Bars Between",  minval=5,   maxval=50,                 group=grp_ETH)
cfg_ETH_conf      = input.float(80,  "Confidence Min %",  minval=30,  maxval=95,  step=5,        group=grp_ETH)
cfg_ETH_volMult   = input.float(2.0, "Volume Multiplier", minval=0.5, maxval=5.0, step=0.1,     group=grp_ETH)
cfg_ETH_ob        = input.float(1.5, "OB Level",          minval=0.3, maxval=3.0, step=0.1,     group=grp_ETH)
cfg_ETH_os        = input.float(-1.5,"OS Level",          minval=-3.0,maxval=-0.3,step=0.1,     group=grp_ETH)
cfg_ETH_aFloor    = input.float(0.0, "Alpha Floor (0=off)",minval=0.0,maxval=0.50,step=0.01,    group=grp_ETH)
cfg_ETH_htf       = input.bool(true, "Use HTF Filter",    group=grp_ETH)
cfg_ETH_trend     = input.bool(true, "Use Trend Filter",  group=grp_ETH)
cfg_ETH_vol       = input.bool(true, "Use Volume Filter", group=grp_ETH)

// â”€â”€â”€ SOL â”€â”€â”€
grp_SOL = "â”€â”€â”€â”€ SOL â”€â”€â”€â”€"
cfg_SOL_alphaM    = input.string("MAMA", "Alpha Method", options=["Homodyne","MAMA","Autocorrelation","Kalman","Manual"], group=grp_SOL,
     tooltip="Alpha estimation method for SOL.\nSOL tiene ciclos mÃ¡s rÃ¡pidos, MAMA o Autocorrelation van bien.")
cfg_SOL_manAlpha  = input.float(0.40, "Manual Alpha (if Manual)", minval=0.05, maxval=0.80, step=0.01, group=grp_SOL)
cfg_SOL_iTrendA   = input.float(0.09, "iTrend Alpha", minval=0.01, maxval=0.3, step=0.01, group=grp_SOL,
     tooltip="iTrend smoothing for SOL.\nSOL is more volatile, slightly higher alpha works.\nSOL: 0.07-0.12 recommended.")
cfg_SOL_trigEma   = input.int(10,    "Trigger EMA",       minval=3,   maxval=30,                 group=grp_SOL)
cfg_SOL_minBars   = input.int(18,    "Min Bars Between",  minval=5,   maxval=50,                 group=grp_SOL)
cfg_SOL_conf      = input.float(75,  "Confidence Min %",  minval=30,  maxval=95,  step=5,        group=grp_SOL)
cfg_SOL_volMult   = input.float(1.2, "Volume Multiplier", minval=0.5, maxval=5.0, step=0.1,     group=grp_SOL)
cfg_SOL_ob        = input.float(1.5, "OB Level",          minval=0.3, maxval=3.0, step=0.1,     group=grp_SOL)
cfg_SOL_os        = input.float(-1.5,"OS Level",          minval=-3.0,maxval=-0.3,step=0.1,     group=grp_SOL)
cfg_SOL_aFloor    = input.float(0.0, "Alpha Floor (0=off)",minval=0.0,maxval=0.50,step=0.01,    group=grp_SOL)
cfg_SOL_htf       = input.bool(true, "Use HTF Filter",    group=grp_SOL)
cfg_SOL_trend     = input.bool(true, "Use Trend Filter",  group=grp_SOL)
cfg_SOL_vol       = input.bool(true, "Use Volume Filter", group=grp_SOL)

// â”€â”€â”€ DOGE â”€â”€â”€
grp_DOGE = "â”€â”€â”€â”€ DOGE â”€â”€â”€â”€"
cfg_DOGE_alphaM   = input.string("Kalman", "Alpha Method", options=["Homodyne","MAMA","Autocorrelation","Kalman","Manual"], group=grp_DOGE,
     tooltip="Alpha estimation method for DOGE.\nKalman handles DOGE's erratic moves well.\nAutocorrelation also solid.")
cfg_DOGE_manAlpha = input.float(0.40, "Manual Alpha (if Manual)", minval=0.05, maxval=0.80, step=0.01, group=grp_DOGE)
cfg_DOGE_iTrendA  = input.float(0.10, "iTrend Alpha", minval=0.01, maxval=0.3, step=0.01, group=grp_DOGE,
     tooltip="iTrend smoothing for DOGE.\nDOGE needs higher alpha to track its spikes.\nDOGE: 0.08-0.15 recommended.")
cfg_DOGE_trigEma  = input.int(9,     "Trigger EMA",       minval=3,   maxval=30,                 group=grp_DOGE)
cfg_DOGE_minBars  = input.int(16,    "Min Bars Between",  minval=5,   maxval=50,                 group=grp_DOGE)
cfg_DOGE_conf     = input.float(75,  "Confidence Min %",  minval=30,  maxval=95,  step=5,        group=grp_DOGE)
cfg_DOGE_volMult  = input.float(1.0, "Volume Multiplier", minval=0.5, maxval=5.0, step=0.1,     group=grp_DOGE)
cfg_DOGE_ob       = input.float(1.5, "OB Level",          minval=0.3, maxval=3.0, step=0.1,     group=grp_DOGE)
cfg_DOGE_os       = input.float(-1.5,"OS Level",          minval=-3.0,maxval=-0.3,step=0.1,     group=grp_DOGE)
cfg_DOGE_aFloor   = input.float(0.0, "Alpha Floor (0=off)",minval=0.0,maxval=0.50,step=0.01,    group=grp_DOGE)
cfg_DOGE_htf      = input.bool(true, "Use HTF Filter",    group=grp_DOGE)
cfg_DOGE_trend    = input.bool(true, "Use Trend Filter",  group=grp_DOGE)
cfg_DOGE_vol      = input.bool(true, "Use Volume Filter", group=grp_DOGE)
// â”€â”€â”€ BCHâ”€â”€â”€
grp_BCH = "â”€â”€â”€â”€ BCH â”€â”€â”€â”€"
cfg_BCH_alphaM   = input.string("Kalman", "Alpha Method", options=["Homodyne","MAMA","Autocorrelation","Kalman","Manual"], group=grp_BCH,
     tooltip="Alpha estimation method for BCH.\nKalman handles BCH's erratic moves well.\nAutocorrelation also solid.")
cfg_BCH_manAlpha = input.float(0.40, "Manual Alpha (if Manual)", minval=0.05, maxval=0.80, step=0.01, group=grp_BCH)
cfg_BCH_iTrendA  = input.float(0.10, "iTrend Alpha", minval=0.01, maxval=0.3, step=0.01, group=grp_BCH,
     tooltip="iTrend smoothing for BCH.\nBCH needs higher alpha to track its spikes.\nBCH: 0.08-0.15 recommended.")
cfg_BCH_trigEma  = input.int(9,     "Trigger EMA",       minval=3,   maxval=30,                 group=grp_BCH)
cfg_BCH_minBars  = input.int(16,    "Min Bars Between",  minval=5,   maxval=50,                 group=grp_BCH)
cfg_BCH_conf     = input.float(75,  "Confidence Min %",  minval=30,  maxval=95,  step=5,        group=grp_BCH)
cfg_BCH_volMult  = input.float(1.0, "Volume Multiplier", minval=0.5, maxval=5.0, step=0.1,     group=grp_BCH)
cfg_BCH_ob       = input.float(1.5, "OB Level",          minval=0.3, maxval=3.0, step=0.1,     group=grp_BCH)
cfg_BCH_os       = input.float(-1.5,"OS Level",          minval=-3.0,maxval=-0.3,step=0.1,     group=grp_BCH)
cfg_BCH_aFloor   = input.float(0.0, "Alpha Floor (0=off)",minval=0.0,maxval=0.50,step=0.01,    group=grp_BCH)
cfg_BCH_htf      = input.bool(true, "Use HTF Filter",    group=grp_BCH)
cfg_BCH_trend    = input.bool(true, "Use Trend Filter",  group=grp_BCH)
cfg_BCH_vol      = input.bool(true, "Use Volume Filter", group=grp_BCH)
// â”€â”€â”€ UNI â”€â”€â”€
grp_UNI = "â”€â”€â”€â”€ UNI â”€â”€â”€â”€"
cfg_UNI_alphaM   = input.string("Kalman", "Alpha Method", options=["Homodyne","MAMA","Autocorrelation","Kalman","Manual"], group=grp_UNI,
     tooltip="Alpha estimation method for UNI.\nKalman handles UNI's erratic moves well.\nAutocorrelation also solid.")
cfg_UNI_manAlpha = input.float(0.40, "Manual Alpha (if Manual)", minval=0.05, maxval=0.80, step=0.01, group=grp_UNI)
cfg_UNI_iTrendA  = input.float(0.10, "iTrend Alpha", minval=0.01, maxval=0.3, step=0.01, group=grp_UNI,
     tooltip="iTrend smoothing for UNI.\nUNI needs higher alpha to track its spikes.\nUNI: 0.08-0.15 recommended.")
cfg_UNI_trigEma  = input.int(9,     "Trigger EMA",       minval=3,   maxval=30,                 group=grp_UNI)
cfg_UNI_minBars  = input.int(16,    "Min Bars Between",  minval=5,   maxval=50,                 group=grp_UNI)
cfg_UNI_conf     = input.float(75,  "Confidence Min %",  minval=30,  maxval=95,  step=5,        group=grp_UNI)
cfg_UNI_volMult  = input.float(1.0, "Volume Multiplier", minval=0.5, maxval=5.0, step=0.1,     group=grp_UNI)
cfg_UNI_ob       = input.float(1.5, "OB Level",          minval=0.3, maxval=3.0, step=0.1,     group=grp_UNI)
cfg_UNI_os       = input.float(-1.5,"OS Level",          minval=-3.0,maxval=-0.3,step=0.1,     group=grp_UNI)
cfg_UNI_aFloor   = input.float(0.0, "Alpha Floor (0=off)",minval=0.0,maxval=0.50,step=0.01,    group=grp_UNI)
cfg_UNI_htf      = input.bool(true, "Use HTF Filter",    group=grp_UNI)
cfg_UNI_trend    = input.bool(true, "Use Trend Filter",  group=grp_UNI)
cfg_UNI_vol      = input.bool(true, "Use Volume Filter", group=grp_UNI)
// â”€â”€â”€ PEPE â”€â”€â”€
grp_PEPE = "â”€â”€â”€â”€ PEPE â”€â”€â”€â”€"
cfg_PEPE_alphaM   = input.string("Kalman", "Alpha Method", options=["Homodyne","MAMA","Autocorrelation","Kalman","Manual"], group=grp_PEPE,
     tooltip="Alpha estimation method for PEPE.\nKalman handles PEPE's erratic moves well.\nAutocorrelation also solid.")
cfg_PEPE_manAlpha = input.float(0.40, "Manual Alpha (if Manual)", minval=0.05, maxval=0.80, step=0.01, group=grp_PEPE)
cfg_PEPE_iTrendA  = input.float(0.10, "iTrend Alpha", minval=0.01, maxval=0.3, step=0.01, group=grp_PEPE,
     tooltip="iTrend smoothing for PEPE.\nPEPE needs higher alpha to track its spikes.\nPEPE: 0.08-0.15 recommended.")
cfg_PEPE_trigEma  = input.int(9,     "Trigger EMA",       minval=3,   maxval=30,                 group=grp_PEPE)
cfg_PEPE_minBars  = input.int(16,    "Min Bars Between",  minval=5,   maxval=50,                 group=grp_PEPE)
cfg_PEPE_conf     = input.float(75,  "Confidence Min %",  minval=30,  maxval=95,  step=5,        group=grp_PEPE)
cfg_PEPE_volMult  = input.float(1.0, "Volume Multiplier", minval=0.5, maxval=5.0, step=0.1,     group=grp_PEPE)
cfg_PEPE_ob       = input.float(1.5, "OB Level",          minval=0.3, maxval=3.0, step=0.1,     group=grp_PEPE)
cfg_PEPE_os       = input.float(-1.5,"OS Level",          minval=-3.0,maxval=-0.3,step=0.1,     group=grp_PEPE)
cfg_PEPE_aFloor   = input.float(0.0, "Alpha Floor (0=off)",minval=0.0,maxval=0.50,step=0.01,    group=grp_PEPE)
cfg_PEPE_htf      = input.bool(true, "Use HTF Filter",    group=grp_PEPE)
cfg_PEPE_trend    = input.bool(true, "Use Trend Filter",  group=grp_PEPE)
cfg_PEPE_vol      = input.bool(true, "Use Volume Filter", group=grp_PEPE)
// â”€â”€â”€ ONDO â”€â”€â”€
grp_ONDO = "â”€â”€â”€â”€ ONDO â”€â”€â”€â”€"
cfg_ONDO_alphaM   = input.string("Kalman", "Alpha Method", options=["Homodyne","MAMA","Autocorrelation","Kalman","Manual"], group=grp_ONDO,
     tooltip="Alpha estimation method for ONDO.\nKalman handles ONDO's erratic moves well.\nAutocorrelation also solid.")
cfg_ONDO_manAlpha = input.float(0.40, "Manual Alpha (if Manual)", minval=0.05, maxval=0.80, step=0.01, group=grp_ONDO)
cfg_ONDO_iTrendA  = input.float(0.10, "iTrend Alpha", minval=0.01, maxval=0.3, step=0.01, group=grp_ONDO,
     tooltip="iTrend smoothing for ONDO.\nONDO needs higher alpha to track its spikes.\nONDO: 0.08-0.15 recommended.")
cfg_ONDO_trigEma  = input.int(9,     "Trigger EMA",       minval=3,   maxval=30,                 group=grp_ONDO)
cfg_ONDO_minBars  = input.int(16,    "Min Bars Between",  minval=5,   maxval=50,                 group=grp_ONDO)
cfg_ONDO_conf     = input.float(75,  "Confidence Min %",  minval=30,  maxval=95,  step=5,        group=grp_ONDO)
cfg_ONDO_volMult  = input.float(1.0, "Volume Multiplier", minval=0.5, maxval=5.0, step=0.1,     group=grp_ONDO)
cfg_ONDO_ob       = input.float(1.5, "OB Level",          minval=0.3, maxval=3.0, step=0.1,     group=grp_ONDO)
cfg_ONDO_os       = input.float(-1.5,"OS Level",          minval=-3.0,maxval=-0.3,step=0.1,     group=grp_ONDO)
cfg_ONDO_aFloor   = input.float(0.0, "Alpha Floor (0=off)",minval=0.0,maxval=0.50,step=0.01,    group=grp_ONDO)
cfg_ONDO_htf      = input.bool(true, "Use HTF Filter",    group=grp_ONDO)
cfg_ONDO_trend    = input.bool(true, "Use Trend Filter",  group=grp_ONDO)
cfg_ONDO_vol      = input.bool(true, "Use Volume Filter", group=grp_ONDO)
// â”€â”€â”€ DEFAULT â”€â”€â”€
grp_DEF = "â”€â”€â”€â”€ DEFAULT â”€â”€â”€â”€"
cfg_DEF_alphaM    = input.string("MAMA", "Alpha Method", options=["Homodyne","MAMA","Autocorrelation","Kalman","Manual"], group=grp_DEF,
     tooltip="Alpha estimation method for unrecognized coins.\nMAMA is a safe default.")
cfg_DEF_manAlpha  = input.float(0.35, "Manual Alpha (if Manual)", minval=0.05, maxval=0.80, step=0.01, group=grp_DEF)
cfg_DEF_iTrendA   = input.float(0.07, "iTrend Alpha", minval=0.01, maxval=0.3, step=0.01, group=grp_DEF,
     tooltip="iTrend smoothing for default coins.")
cfg_DEF_trigEma   = input.int(10,    "Trigger EMA",       minval=3,   maxval=30,                 group=grp_DEF)
cfg_DEF_minBars   = input.int(18,    "Min Bars Between",  minval=5,   maxval=50,                 group=grp_DEF)
cfg_DEF_conf      = input.float(75,  "Confidence Min %",  minval=30,  maxval=95,  step=5,        group=grp_DEF)
cfg_DEF_volMult   = input.float(1.5, "Volume Multiplier", minval=0.5, maxval=5.0, step=0.1,     group=grp_DEF)
cfg_DEF_ob        = input.float(1.5, "OB Level",          minval=0.3, maxval=3.0, step=0.1,     group=grp_DEF)
cfg_DEF_os        = input.float(-1.5,"OS Level",          minval=-3.0,maxval=-0.3,step=0.1,     group=grp_DEF)
cfg_DEF_aFloor    = input.float(0.0, "Alpha Floor (0=off)",minval=0.0,maxval=0.50,step=0.01,    group=grp_DEF)
cfg_DEF_htf       = input.bool(true, "Use HTF Filter",    group=grp_DEF)
cfg_DEF_trend     = input.bool(true, "Use Trend Filter",  group=grp_DEF)
cfg_DEF_vol       = input.bool(true, "Use Volume Filter", group=grp_DEF)


// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                     REGIME FILTERS                               â•‘
// â•‘  5 independent filters to suppress signals during ranging        â•‘
// â•‘  Each is toggleable â€” combine as needed                          â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

grp_regime = "â•â•â•â•â•â• REGIME FILTERS â•â•â•â•â•â•"

// â”€â”€â”€ P1: CYCLE AMPLITUDE â”€â”€â”€
bool   useAmpFilter  = input.bool (true, "â‘  Cycle Amplitude Filter", group=grp_regime,
     tooltip="Suppresses signals when the CyberCycle amplitude is too small relative to its history.\nThis is the most direct ranging detector â€” if the cycle is tiny, there's nothing to trade.")
int    ampLookback   = input.int  (50,   "  Amp Lookback",   minval=20, maxval=200, group=grp_regime,
     tooltip="Bars to average for historical amplitude baseline.\n50 = ~2 days at 1H.")
float  ampThreshold  = input.float(0.40, "  Amp Threshold",  minval=0.10, maxval=0.90, step=0.05, group=grp_regime,
     tooltip="Min ratio of current amplitude vs average.\n0.40 = cycle must be â‰¥40% of its average size.\nLower = more signals in ranging (riskier).\nHigher = only strong cycles trade.")

// â”€â”€â”€ P2: SQUEEZE (BB inside KC) â”€â”€â”€
bool   useSqueeze    = input.bool (true, "â‘¡ Squeeze Filter (BB/KC)", group=grp_regime,
     tooltip="Detects Bollinger Bands inside Keltner Channels = volatility compression = ranging.\nInspired by John Carter's TTM Squeeze.\nNo signals during squeeze.")
int    sqzLen        = input.int  (20,   "  Squeeze Length",  minval=10, maxval=50,  group=grp_regime)
float  sqzBBMult     = input.float(2.0,  "  BB Multiplier",  minval=1.0, maxval=3.0, step=0.1, group=grp_regime)
float  sqzKCMult     = input.float(1.5,  "  KC Multiplier",  minval=0.5, maxval=3.0, step=0.1, group=grp_regime,
     tooltip="BB Mult=2.0, KC Mult=1.5 is the classic Carter setup.\nLower KC Mult = detects tighter squeezes only.\nHigher KC Mult = more aggressive filtering.")

// â”€â”€â”€ P3: ADX â”€â”€â”€
bool   useADX        = input.bool (true, "â‘¢ ADX Trend Strength", group=grp_regime,
     tooltip="Classic ADX filter. ADX < threshold = no directional movement = ranging.\nSimple and reliable complementary filter.")
int    adxLen        = input.int  (14,   "  ADX Length",      minval=7,  maxval=30,  group=grp_regime)
float  adxMinVal     = input.float(20.0, "  ADX Minimum",    minval=10.0,maxval=40.0,step=1.0, group=grp_regime,
     tooltip="ADX below this = ranging.\n20 is the classic Wilder threshold.\nCrypto: 18-25 works well.\nHigher = more restrictive.")

// â”€â”€â”€ P4: CYCLE STRENGTH (Autocorrelation Peak) â”€â”€â”€
bool   useCycleStr   = input.bool (false,"â‘£ Cycle Strength (Autocorr)", group=grp_regime,
     tooltip="Uses the peak correlation from the Autocorrelation Periodogram.\nIf no dominant cycle is clear (low correlation), signals are suppressed.\nThis is the most 'Ehlers-native' filter but requires Autocorrelation method to run.\nWorks with any alpha method since all methods run every bar.")
float  minCycleCorr  = input.float(0.40, "  Min Correlation", minval=0.15, maxval=0.85, step=0.05, group=grp_regime,
     tooltip="Minimum autocorrelation peak strength.\n0.40 = moderate cycle quality.\n0.60 = strong cycle required.\nCrypto is noisy â€” 0.30-0.50 typical range.")

// â”€â”€â”€ P5: SNR (Signal-to-Noise Ratio) â”€â”€â”€
bool   useSNR        = input.bool (false,"â‘¤ SNR Filter (dB)", group=grp_regime,
     tooltip="Measures the Signal-to-Noise ratio of the CyberCycle.\nIf the cycle power is weak compared to price noise, it's likely ranging.\nMore theoretical â€” use as complementary filter.")
float  snrMinDB      = input.float(3.0,  "  Min SNR (dB)",   minval=0.5, maxval=10.0, step=0.5, group=grp_regime,
     tooltip="Minimum SNR in decibels.\n3 dB = signal is 2Ã— stronger than noise.\n6 dB = 4Ã— stronger.\nCrypto: 2-4 dB is realistic.")
int    snrSmoothLen  = input.int  (20,   "  SNR Smooth Len", minval=5, maxval=50, group=grp_regime,
     tooltip="Smoothing length for SNR calculation.\nHigher = more stable but slower to react.")


// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                     COIN DETECTION                              â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

string baseCur = syminfo.basecurrency
string detectedCoin = switch baseCur
    "BTC"  => "BTC"
    "ETH"  => "ETH"
    "SOL"  => "SOL"
    "DOGE" => "DOGE"
    "BCH" => "BCH"
    "UNI" => "UNI"
    "PEPE" => "PEPE"
    "ONDO" => "ONDO"
    => "DEF"

// â”€â”€â”€ Per-coin Alpha Method â”€â”€â”€
string eAlphaMethod = switch detectedCoin
    "BTC"  => cfg_BTC_alphaM
    "ETH"  => cfg_ETH_alphaM
    "SOL"  => cfg_SOL_alphaM
    "DOGE" => cfg_DOGE_alphaM
    "BCH" => cfg_BCH_alphaM
    "UNI" => cfg_UNI_alphaM
    "PEPE" => cfg_PEPE_alphaM
    "ONDO" => cfg_ONDO_alphaM
    => cfg_DEF_alphaM

// â”€â”€â”€ Per-coin Manual Alpha â”€â”€â”€
float eManualAlpha = switch detectedCoin
    "BTC"  => cfg_BTC_manAlpha
    "ETH"  => cfg_ETH_manAlpha
    "SOL"  => cfg_SOL_manAlpha
    "DOGE" => cfg_DOGE_manAlpha
    "BCH" => cfg_BCH_manAlpha
    "UNI" => cfg_UNI_manAlpha
    "PEPE" => cfg_PEPE_manAlpha
    "ONDO" => cfg_ONDO_manAlpha
    => cfg_DEF_manAlpha

// â”€â”€â”€ Per-coin iTrend Alpha â”€â”€â”€
float eITrendAlpha = switch detectedCoin
    "BTC"  => cfg_BTC_iTrendA
    "ETH"  => cfg_ETH_iTrendA
    "SOL"  => cfg_SOL_iTrendA
    "DOGE" => cfg_DOGE_iTrendA
     "BCH" => cfg_BCH_iTrendA
    "UNI" => cfg_UNI_iTrendA
    "PEPE" => cfg_PEPE_iTrendA
    "ONDO" => cfg_ONDO_iTrendA

    => cfg_DEF_iTrendA

int    eTrigEma   = switch detectedCoin
    "BTC" => cfg_BTC_trigEma,  
    "ETH" => cfg_ETH_trigEma,
    "SOL" => cfg_SOL_trigEma,  
    "DOGE" => cfg_DOGE_trigEma,
     "BCH" => cfg_BCH_trigEma
    "UNI" => cfg_UNI_trigEma
    "PEPE" => cfg_PEPE_trigEma
    "ONDO" => cfg_ONDO_trigEma
    => cfg_DEF_trigEma
int    eMinBars   = switch detectedCoin
    "BTC" => cfg_BTC_minBars,  
    "ETH" => cfg_ETH_minBars,
    "SOL" => cfg_SOL_minBars,  
    "DOGE" => cfg_DOGE_minBars,
     "BCH" => cfg_BCH_minBars
    "UNI" => cfg_UNI_minBars
    "PEPE" => cfg_PEPE_minBars
    "ONDO" => cfg_ONDO_minBars
    => cfg_DEF_minBars
float  eCoinConf  = switch detectedCoin
    "BTC" => cfg_BTC_conf,     
    "ETH" => cfg_ETH_conf,
    "SOL" => cfg_SOL_conf,     
    "DOGE" => cfg_DOGE_conf,
     "BCH" => cfg_BCH_conf
    "UNI" => cfg_UNI_conf
    "PEPE" => cfg_PEPE_conf
    "ONDO" => cfg_ONDO_conf
    => cfg_DEF_conf
float  eVolMult   = switch detectedCoin
    "BTC" => cfg_BTC_volMult,  
    "ETH" => cfg_ETH_volMult,
    "SOL" => cfg_SOL_volMult,  
    "DOGE" => cfg_DOGE_volMult,
     "BCH" => cfg_BCH_volMult
    "UNI" => cfg_UNI_volMult
    "PEPE" => cfg_PEPE_volMult
    "ONDO" => cfg_ONDO_volMult
    => cfg_DEF_volMult
float  eOB        = switch detectedCoin
    "BTC" => cfg_BTC_ob,       
    "ETH" => cfg_ETH_ob,
    "SOL" => cfg_SOL_ob,       
    "DOGE" => cfg_DOGE_ob,
     "BCH" => cfg_BCH_ob
    "UNI" => cfg_UNI_ob
    "PEPE" => cfg_PEPE_ob
    "ONDO" => cfg_ONDO_ob
    => cfg_DEF_ob
float  eOS        = switch detectedCoin
    "BTC" => cfg_BTC_os,       
    "ETH" => cfg_ETH_os,
    "SOL" => cfg_SOL_os,       
    "DOGE" => cfg_DOGE_os,
    "BCH" => cfg_BCH_os
    "UNI" => cfg_UNI_os
    "PEPE" => cfg_PEPE_os
    "ONDO" => cfg_ONDO_os
    => cfg_DEF_os
float  eAFloor    = switch detectedCoin
    "BTC" => cfg_BTC_aFloor,   
    "ETH" => cfg_ETH_aFloor,
    "SOL" => cfg_SOL_aFloor,   
    "DOGE" => cfg_DOGE_aFloor,
    "BCH" => cfg_BCH_aFloor
    "UNI" => cfg_UNI_aFloor
    "PEPE" => cfg_PEPE_aFloor
    "ONDO" => cfg_ONDO_aFloor
    => cfg_DEF_aFloor
bool   eUseHTF    = switch detectedCoin
    "BTC" => cfg_BTC_htf,      
    "ETH" => cfg_ETH_htf,
    "SOL" => cfg_SOL_htf,      
    "DOGE" => cfg_DOGE_htf,
    "BCH" => cfg_BCH_htf
    "UNI" => cfg_UNI_htf
    "PEPE" => cfg_PEPE_htf
    "ONDO" => cfg_ONDO_htf
    => cfg_DEF_htf
bool   eUseTrend  = switch detectedCoin
    "BTC" => cfg_BTC_trend,    
    "ETH" => cfg_ETH_trend,
    "SOL" => cfg_SOL_trend,    
    "DOGE" => cfg_DOGE_trend,
    "BCH" => cfg_BCH_trend
    "UNI" => cfg_UNI_trend
    "PEPE" => cfg_PEPE_trend
    "ONDO" => cfg_ONDO_trend
    => cfg_DEF_trend
bool   eUseVol    = switch detectedCoin
    "BTC" => cfg_BTC_vol,      
    "ETH" => cfg_ETH_vol,
    "SOL" => cfg_SOL_vol,      
    "DOGE" => cfg_DOGE_vol,
    "BCH" => cfg_BCH_vol
    "UNI" => cfg_UNI_vol
    "PEPE" => cfg_PEPE_vol
    "ONDO" => cfg_ONDO_vol
    => cfg_DEF_vol

float minConf = switch signalMode
    "Conservative" => 80.0
    "Standard"     => 50.0
    "Aggressive"   => 30.0
    => eCoinConf


// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘              ALPHA METHOD 1: HOMODYNE DISCRIMINATOR             â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

f_homodyne() =>
    var float _hd_smooth = 0.0
    _hd_smooth := (4.0 * srcCyber + 3.0 * nz(srcCyber[1]) + 2.0 * nz(srcCyber[2]) + nz(srcCyber[3])) / 10.0

    var float _hd_period = 15.0
    float _hd_adj = 0.075 * nz(_hd_period[1], 15.0) + 0.54

    var float _hd_det = 0.0
    _hd_det := (0.0962 * _hd_smooth + 0.5769 * nz(_hd_smooth[2]) - 0.5769 * nz(_hd_smooth[4]) - 0.0962 * nz(_hd_smooth[6])) * _hd_adj

    var float _hd_Q1 = 0.0
    _hd_Q1 := (0.0962 * _hd_det + 0.5769 * nz(_hd_det[2]) - 0.5769 * nz(_hd_det[4]) - 0.0962 * nz(_hd_det[6])) * _hd_adj
    float _hd_I1 = nz(_hd_det[3])

    var float _hd_jI = 0.0
    var float _hd_jQ = 0.0
    _hd_jI := (0.0962 * _hd_I1 + 0.5769 * nz(_hd_I1[2]) - 0.5769 * nz(_hd_I1[4]) - 0.0962 * nz(_hd_I1[6])) * _hd_adj
    _hd_jQ := (0.0962 * _hd_Q1 + 0.5769 * nz(_hd_Q1[2]) - 0.5769 * nz(_hd_Q1[4]) - 0.0962 * nz(_hd_Q1[6])) * _hd_adj

    var float _hd_I2 = 0.0
    var float _hd_Q2 = 0.0
    _hd_I2 := 0.2 * (_hd_I1 - _hd_jQ) + 0.8 * nz(_hd_I2[1])
    _hd_Q2 := 0.2 * (_hd_Q1 + _hd_jI) + 0.8 * nz(_hd_Q2[1])

    var float _hd_Re = 0.0
    var float _hd_Im = 0.0
    _hd_Re := 0.2 * (_hd_I2 * nz(_hd_I2[1]) + _hd_Q2 * nz(_hd_Q2[1])) + 0.8 * nz(_hd_Re[1])
    _hd_Im := 0.2 * (_hd_I2 * nz(_hd_Q2[1]) - _hd_Q2 * nz(_hd_I2[1])) + 0.8 * nz(_hd_Im[1])

    float _hd_phaseAdv = (math.abs(_hd_Im) > 1e-10 and math.abs(_hd_Re) > 1e-10) ? math.atan(_hd_Im / _hd_Re) : 0.0
    float _hd_rawPer = _hd_phaseAdv > 0.001 ? 2.0 * math.pi / _hd_phaseAdv : nz(_hd_period[1], 15.0)
    _hd_rawPer := math.max(_hd_rawPer, 0.67 * nz(_hd_period[1], 15.0))
    _hd_rawPer := math.min(_hd_rawPer, 1.5 * nz(_hd_period[1], 15.0))
    _hd_rawPer := math.max(hdMinPeriod, math.min(hdMaxPeriod, _hd_rawPer))
    _hd_period := 0.2 * _hd_rawPer + 0.8 * nz(_hd_period[1], 15.0)

    var float _hd_smoothPeriod = 15.0
    _hd_smoothPeriod := 0.33 * _hd_period + 0.67 * nz(_hd_smoothPeriod[1], 15.0)
    _hd_smoothPeriod := math.max(hdMinPeriod, math.min(hdMaxPeriod, _hd_smoothPeriod))

    float _alpha = 2.0 / (_hd_smoothPeriod + 1.0)
    [_alpha, _hd_smoothPeriod]


// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘              ALPHA METHOD 2: MAMA (Phase Rate)                  â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

f_mama() =>
    float _m_adj = 1.665  // Fixed: 0.075 * 15.0 + 0.54

    var float _m_smooth = 0.0
    _m_smooth := (4.0 * srcCyber + 3.0 * nz(srcCyber[1]) + 2.0 * nz(srcCyber[2]) + nz(srcCyber[3])) / 10.0

    var float _m_det = 0.0
    _m_det := (0.0962 * _m_smooth + 0.5769 * nz(_m_smooth[2]) - 0.5769 * nz(_m_smooth[4]) - 0.0962 * nz(_m_smooth[6])) * _m_adj

    var float _m_Q1 = 0.0
    _m_Q1 := (0.0962 * _m_det + 0.5769 * nz(_m_det[2]) - 0.5769 * nz(_m_det[4]) - 0.0962 * nz(_m_det[6])) * _m_adj
    float _m_I1 = nz(_m_det[3])

    var float _m_jI = 0.0
    var float _m_jQ = 0.0
    _m_jI := (0.0962 * _m_I1 + 0.5769 * nz(_m_I1[2]) - 0.5769 * nz(_m_I1[4]) - 0.0962 * nz(_m_I1[6])) * _m_adj
    _m_jQ := (0.0962 * _m_Q1 + 0.5769 * nz(_m_Q1[2]) - 0.5769 * nz(_m_Q1[4]) - 0.0962 * nz(_m_Q1[6])) * _m_adj

    var float _m_I2 = 0.0
    var float _m_Q2 = 0.0
    _m_I2 := 0.2 * (_m_I1 - _m_jQ) + 0.8 * nz(_m_I2[1])
    _m_Q2 := 0.2 * (_m_Q1 + _m_jI) + 0.8 * nz(_m_Q2[1])

    float _m_sumI = _m_I1 + nz(_m_I1[1])
    float _m_sumQ = _m_Q1 + nz(_m_Q1[1])

    var float _m_phase = 0.0
    float _m_rawPhase = 0.0

    if math.abs(_m_sumI) > 0.001
        _m_rawPhase := math.atan(math.abs(_m_sumQ / _m_sumI)) * (180.0 / math.pi)
    else
        _m_rawPhase := 90.0

    if _m_sumI < 0 and _m_sumQ > 0
        _m_rawPhase := 180.0 - _m_rawPhase
    else if _m_sumI < 0 and _m_sumQ < 0
        _m_rawPhase := 180.0 + _m_rawPhase
    else if _m_sumI > 0 and _m_sumQ < 0
        _m_rawPhase := 360.0 - _m_rawPhase

    _m_phase := _m_rawPhase

    float _m_dp_raw = nz(_m_phase[1], 0.0) - _m_phase

    if _m_dp_raw > 180.0
        _m_dp_raw := _m_dp_raw - 360.0
    if _m_dp_raw < -180.0
        _m_dp_raw := _m_dp_raw + 360.0

    float _m_dp = math.max(1.0, math.min(60.0, _m_dp_raw))

    var float _m_dpSmooth = 5.0
    _m_dpSmooth := 0.33 * _m_dp + 0.67 * nz(_m_dpSmooth[1], 5.0)
    _m_dpSmooth := math.max(1.0, math.min(60.0, _m_dpSmooth))

    float _m_alpha = mamaFastLimit / _m_dpSmooth
    _m_alpha := math.max(mamaSlowLimit, math.min(mamaFastLimit, _m_alpha))

    float _m_periodEst = math.max(2.0, (2.0 / _m_alpha) - 1.0)

    [_m_alpha, _m_periodEst]


// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘         ALPHA METHOD 3: AUTOCORRELATION PERIODOGRAM             â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

f_autocorrelation() =>
    float _ac_a1 = (0.707 * 2.0 * math.pi) / acMaxPeriod
    float _ac_alphaHP = (math.cos(_ac_a1) + math.sin(_ac_a1) - 1.0) / math.cos(_ac_a1)

    var float _ac_hp = 0.0
    _ac_hp := (1.0 - _ac_alphaHP / 2.0) * (1.0 - _ac_alphaHP / 2.0) * (srcCyber - 2.0 * nz(srcCyber[1]) + nz(srcCyber[2])) + 2.0 * (1.0 - _ac_alphaHP) * nz(_ac_hp[1]) - (1.0 - _ac_alphaHP) * (1.0 - _ac_alphaHP) * nz(_ac_hp[2])

    float _ac_a1ss = math.exp(-1.414 * math.pi / acMinPeriod)
    float _ac_b1ss = 2.0 * _ac_a1ss * math.cos(1.414 * math.pi / acMinPeriod)
    float _ac_c2ss = _ac_b1ss
    float _ac_c3ss = -_ac_a1ss * _ac_a1ss
    float _ac_c1ss = 1.0 - _ac_c2ss - _ac_c3ss

    var float _ac_filt = 0.0
    _ac_filt := _ac_c1ss * (_ac_hp + nz(_ac_hp[1])) / 2.0 + _ac_c2ss * nz(_ac_filt[1]) + _ac_c3ss * nz(_ac_filt[2])

    int _ac_step = math.max(1, (acMaxPeriod - acMinPeriod) / 10)

    var float _ac_bestPeriod = 15.0
    float _ac_maxCorr = 0.0
    float _ac_bestP = _ac_bestPeriod

    for p = acMinPeriod to acMaxPeriod by _ac_step
        float _sx = 0.0
        float _sy = 0.0
        float _sxx = 0.0
        float _syy = 0.0
        float _sxy = 0.0
        int _cnt = acAvgLength * p
        for j = 0 to math.min(_cnt - 1, 199)
            float _x = nz(_ac_filt[j])
            float _y = nz(_ac_filt[j + p])
            _sx += _x
            _sy += _y
            _sxx += _x * _x
            _syy += _y * _y
            _sxy += _x * _y
        float _denom = (_cnt * _sxx - _sx * _sx) * (_cnt * _syy - _sy * _sy)
        float _corr = _denom > 0 ? (_cnt * _sxy - _sx * _sy) / math.sqrt(_denom) : 0.0
        if _corr > _ac_maxCorr
            _ac_maxCorr := _corr
            _ac_bestP := float(p)

    _ac_bestPeriod := 0.25 * _ac_bestP + 0.75 * nz(_ac_bestPeriod[1], 15.0)
    _ac_bestPeriod := math.max(acMinPeriod, math.min(acMaxPeriod, _ac_bestPeriod))

    float _ac_alpha = 2.0 / (_ac_bestPeriod + 1.0)
    [_ac_alpha, _ac_bestPeriod, _ac_maxCorr]


// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘          ALPHA METHOD 4: KALMAN INNOVATION-BASED                â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

f_kalman() =>
    var float _k_x = srcCyber
    var float _k_P = 1.0
    var float _k_innovEma = 0.001

    float _k_xPred = _k_x
    float _k_PPred = _k_P + kalProcessNoise

    float _k_innovation = srcCyber - _k_xPred
    float _k_S = _k_PPred + kalMeasNoise
    float _k_K = _k_S > 1e-12 ? _k_PPred / _k_S : 0.5

    _k_x := _k_xPred + _k_K * _k_innovation
    _k_P := (1.0 - _k_K) * _k_PPred

    float _k_absInnov = math.abs(_k_innovation)
    _k_innovEma := 0.05 * _k_absInnov + 0.95 * nz(_k_innovEma[1], 0.001)

    float _k_normInnov = _k_innovEma > 1e-12 ? _k_absInnov / _k_innovEma : 1.0
    float _k_ratio = (_k_normInnov - 1.0) * kalSensitivity
    float _k_sigmoid = 1.0 / (1.0 + math.exp(-_k_ratio))
    float _k_alpha = kalAlphaSlow + (kalAlphaFast - kalAlphaSlow) * _k_sigmoid
    _k_alpha := math.max(kalAlphaSlow, math.min(kalAlphaFast, _k_alpha))

    float _k_period = math.max(2.0, (2.0 / _k_alpha) - 1.0)

    [_k_alpha, _k_period]


// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                  ALPHA METHOD DISPATCHER                        â•‘
// â•‘  Now uses per-coin eAlphaMethod instead of global               â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// All methods must be called every bar to maintain state continuity.
// Pine Script requires consistent execution â€” skipping a method on some
// bars would corrupt its internal var state on subsequent bars.
[_a_hd, _p_hd] = f_homodyne()
[_a_ma, _p_ma] = f_mama()
[_a_ac, _p_ac, _ac_peakCorr] = f_autocorrelation()
[_a_kl, _p_kl] = f_kalman()

float adaptiveAlpha = switch eAlphaMethod
    "Homodyne"        => _a_hd
    "MAMA"            => _a_ma
    "Autocorrelation" => _a_ac
    "Kalman"          => _a_kl
    => eManualAlpha  // Manual

float dominantPeriod = switch eAlphaMethod
    "Homodyne"        => _p_hd
    "MAMA"            => _p_ma
    "Autocorrelation" => _p_ac
    "Kalman"          => _p_kl
    => (2.0 / eManualAlpha) - 1.0  // Manual

// Apply per-coin alpha floor
if eAFloor > 0
    adaptiveAlpha := math.max(adaptiveAlpha, eAFloor)


// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                  ADAPTIVE CYBER CYCLE + SUPPORT                 â•‘
// â•‘  iTrend now uses per-coin eITrendAlpha                          â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

f_ema(float src, int len) =>
    float k = 2.0 / (len + 1)
    var float out = 0.0
    out := k * src + (1.0 - k) * nz(out[1])
    out

var float _mainSmooth = 0.0
var float _mainCycle = 0.0
_mainSmooth := (srcCyber + 2.0 * nz(srcCyber[1]) + 2.0 * nz(srcCyber[2]) + nz(srcCyber[3])) / 6.0
if bar_index < 7
    _mainCycle := (srcCyber - 2.0 * nz(srcCyber[1]) + nz(srcCyber[2])) / 4.0
else
    float _a1 = (1.0 - 0.5 * adaptiveAlpha) * (1.0 - 0.5 * adaptiveAlpha)
    float _a2 = 2.0 * (1.0 - adaptiveAlpha)
    float _a3 = (1.0 - adaptiveAlpha) * (1.0 - adaptiveAlpha)
    _mainCycle := _a1 * (_mainSmooth - 2.0 * nz(_mainSmooth[1]) + nz(_mainSmooth[2])) + _a2 * nz(_mainCycle[1]) - _a3 * nz(_mainCycle[2])

float cyberCycle = _mainCycle
float trigger = f_ema(cyberCycle, eTrigEma)

// iTrend â€” now per-coin alpha
var float _iTrend = 0.0
float _itA = eITrendAlpha
_iTrend := (_itA - _itA * _itA / 4.0) * close + 0.5 * _itA * _itA * nz(close[1]) - (_itA - 0.75 * _itA * _itA) * nz(close[2]) + 2.0 * (1.0 - _itA) * nz(_iTrend[1]) - (1.0 - _itA) * (1.0 - _itA) * nz(_iTrend[2])
float iTrend = _iTrend
bool bullTrend = iTrend > nz(iTrend[2])
bool bearTrend = iTrend < nz(iTrend[2])


// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                     FISHER TRANSFORM                            â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

float _fH = ta.highest(cyberCycle, 10)
float _fL = ta.lowest(cyberCycle, 10)
float _fR = _fH - _fL
float _fV = _fR != 0 ? 2.0 * ((cyberCycle - _fL) / _fR - 0.5) : 0.0
_fV := math.max(-0.999, math.min(0.999, _fV))
float _fRaw = 0.5 * math.log((1.0 + _fV) / (1.0 - _fV))
var float fisherT = 0.0
fisherT := 0.5 * _fRaw + 0.5 * nz(fisherT[1])
bool fishRising  = fisherT > nz(fisherT[1])
bool fishFalling = fisherT < nz(fisherT[1])


// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                     VOLUME FILTER                               â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

float volSma20   = ta.sma(volume, 20)
float volRatio   = volSma20 > 0 ? volume / volSma20 : 0
bool volumeOK    = not eUseVol or volRatio >= eVolMult


// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                     HTF FILTER (4H)                             â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

float htfSrc  = request.security(syminfo.tickerid, "240", hl2, lookahead=barmerge.lookahead_off)
float htfCC   = request.security(syminfo.tickerid, "240",
     ta.ema(close, 10), lookahead=barmerge.lookahead_off)
bool htfBullish = not eUseHTF or htfSrc > htfCC
bool htfBearish = not eUseHTF or htfSrc < htfCC
bool htfAlignBuy  = not eUseHTF or htfBullish
bool htfAlignSell = not eUseHTF or htfBearish


// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘              REGIME FILTER COMPUTATIONS                          â•‘
// â•‘  Each filter independently determines if market is "tradeable"  â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”€â”€â”€ HELPER: ADX (Wilder's Average Directional Index) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Pine doesn't have ta.adx() built-in. Full Wilder implementation.
f_adx(int length) =>
    float _tr  = math.max(high - low, math.max(math.abs(high - nz(close[1])), math.abs(low - nz(close[1]))))
    float _pDM = math.max(high - nz(high[1]), 0.0)
    float _nDM = math.max(nz(low[1]) - low, 0.0)
    if _pDM > _nDM
        _nDM := 0.0
    else
        _pDM := 0.0
    float _strPDM = ta.rma(_pDM, length)
    float _strNDM = ta.rma(_nDM, length)
    float _strTR  = ta.rma(_tr,  length)
    float _pDI = 100.0 * _strPDM / math.max(_strTR, 1e-10)
    float _nDI = 100.0 * _strNDM / math.max(_strTR, 1e-10)
    float _sum = _pDI + _nDI
    float _dx  = _sum > 0.001 ? 100.0 * math.abs(_pDI - _nDI) / _sum : 0.0
    float _adx = ta.rma(_dx, length)
    _adx

// â”€â”€â”€ P1: CYCLE AMPLITUDE FILTER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  If the CyberCycle oscillation is tiny â†’ there's no real cycle â†’ ranging.
//  Measures peak-to-trough of recent cycle and compares to historical average.
float cycleHigh   = ta.highest(cyberCycle, 10)
float cycleLow    = ta.lowest (cyberCycle, 10)
float cycleAmp    = cycleHigh - cycleLow
float avgCycleAmp = ta.sma(cycleAmp, ampLookback)
float ampRatio    = avgCycleAmp > 1e-10 ? cycleAmp / avgCycleAmp : 1.0
bool  ampOK       = not useAmpFilter or ampRatio >= ampThreshold

// â”€â”€â”€ P2: SQUEEZE FILTER (BB inside KC = volatility compression) â”€â”€â”€â”€â”€
//  When Bollinger Bands compress inside Keltner Channels, volatility
//  is at a minimum â†’ market is coiling â†’ ranging. Classic Carter concept.
float sqzBasis  = ta.sma(close, sqzLen)
float sqzDev    = sqzBBMult * ta.stdev(close, sqzLen)
float sqzBBU    = sqzBasis + sqzDev
float sqzBBL    = sqzBasis - sqzDev
float sqzATR    = ta.atr(sqzLen)
float sqzKCU    = sqzBasis + sqzKCMult * sqzATR
float sqzKCL    = sqzBasis - sqzKCMult * sqzATR
bool  inSqueeze = sqzBBL > sqzKCL and sqzBBU < sqzKCU
bool  sqzOK     = not useSqueeze or not inSqueeze

// â”€â”€â”€ P3: ADX TREND STRENGTH â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  Wilder's ADX measures directional movement strength.
//  ADX < threshold = no trend = ranging.
float adxValue = f_adx(adxLen)
bool  adxOK    = not useADX or adxValue >= adxMinVal

// â”€â”€â”€ P4: CYCLE STRENGTH (Autocorrelation Peak Quality) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  The autocorrelation periodogram (already computed in f_autocorrelation)
//  returns the peak correlation at the dominant period.
//  Low correlation = no clear dominant cycle = noise/ranging.
//  _ac_peakCorr is available because all alpha methods run every bar.
bool  cycleStrOK = not useCycleStr or _ac_peakCorr >= minCycleCorr

// â”€â”€â”€ P5: SNR FILTER (Signal-to-Noise Ratio in dB) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
//  Signal power = the CyberCycle component (what we're trading on)
//  Noise power  = high-frequency residual (tick-to-tick changes)
//  If SNR is low â†’ cycle is buried in noise â†’ don't trade.
float sigPower    = cyberCycle * cyberCycle
float noiseRaw    = srcCyber - nz(srcCyber[1])
float noisePower  = noiseRaw * noiseRaw
float avgSigPow   = ta.sma(sigPower,  snrSmoothLen)
float avgNoisePow = ta.sma(noisePower, snrSmoothLen)
float snrRatio    = avgNoisePow > 1e-10 ? avgSigPow / avgNoisePow : 100.0
float snrDB       = 10.0 * math.log10(math.max(snrRatio, 0.001))
bool  snrOK       = not useSNR or snrDB >= snrMinDB

// â”€â”€â”€ COMBINED REGIME VERDICT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
bool regimeOK = ampOK and sqzOK and adxOK and cycleStrOK and snrOK

// Count how many filters are active and passing (for info display)
int regimeActiveCount = 0
int regimePassCount   = 0
if useAmpFilter
    regimeActiveCount += 1
    if ampOK
        regimePassCount += 1
if useSqueeze
    regimeActiveCount += 1
    if sqzOK
        regimePassCount += 1
if useADX
    regimeActiveCount += 1
    if adxOK
        regimePassCount += 1
if useCycleStr
    regimeActiveCount += 1
    if cycleStrOK
        regimePassCount += 1
if useSNR
    regimeActiveCount += 1
    if snrOK
        regimePassCount += 1

// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                     SIGNAL GENERATION                           â•‘
// â•‘  v7.1b: Tick/Time Persistence + Ghost Cooldown Fix              â•‘
// â•‘                                                                  â•‘
// â•‘  GHOST COOLDOWN FIX:                                             â•‘
// â•‘    lastSigBar only updates when a signal PASSES persistence.    â•‘
// â•‘    Phantom signals that die before threshold â†’ completely        â•‘
// â•‘    ignored, as if they never existed. No corrupted cooldown.    â•‘
// â•‘                                                                  â•‘
// â•‘  PERSISTENCE ANTI-REPAINTING:                                   â•‘
// â•‘    A raw signal must stay continuously true for N seconds        â•‘
// â•‘    (or N ticks) before activating. If it flips false before     â•‘
// â•‘    reaching the threshold â†’ reset counter, no signal, no label, â•‘
// â•‘    no cooldown impact. Once persistence is reached â†’ lock ON    â•‘
// â•‘    for the rest of the bar (no more flickering).                â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

bool bullCross = ta.crossover(cyberCycle, trigger)
bool bearCross = ta.crossunder(cyberCycle, trigger)

bool inOB = cyberCycle > eOB
bool inOS = cyberCycle < eOS

float momentum3 = cyberCycle - nz(cyberCycle[3])

// â”€â”€â”€ CONFIDENCE (regime-aware) â”€â”€â”€
float buyConf = 0.0
buyConf += bullCross ? 20.0 : 0.0
buyConf += (eUseTrend ? bullTrend : true) ? 15.0 : 0.0
buyConf += inOS ? 15.0 : 0.0
buyConf += (eUseVol ? volumeOK : true) ? 15.0 : 0.0
buyConf += fishRising ? 10.0 : 0.0
buyConf += momentum3 > 0 ? 10.0 : 0.0
buyConf += htfAlignBuy ? 15.0 : 0.0
buyConf += regimeOK ? 10.0 : -15.0
buyConf := math.max(0.0, math.min(buyConf, 100.0))

float sellConf = 0.0
sellConf += bearCross ? 20.0 : 0.0
sellConf += (eUseTrend ? bearTrend : true) ? 15.0 : 0.0
sellConf += inOB ? 15.0 : 0.0
sellConf += (eUseVol ? volumeOK : true) ? 15.0 : 0.0
sellConf += fishFalling ? 10.0 : 0.0
sellConf += momentum3 < 0 ? 10.0 : 0.0
sellConf += htfAlignSell ? 15.0 : 0.0
sellConf += regimeOK ? 10.0 : -15.0
sellConf := math.max(0.0, math.min(sellConf, 100.0))

// â”€â”€â”€ BAR FILTER (ghost-proof) â”€â”€â”€
// Only updated when a signal PASSES persistence â†’ phantoms can't corrupt it
var int lastSigBar_safe = 0
bool barFilter = bar_index - lastSigBar_safe >= eMinBars

// â”€â”€â”€ RAW SIGNALS (instantaneous, before persistence) â”€â”€â”€
bool rawBuy  = bullCross and buyConf >= minConf and barFilter and (eUseTrend ? bullTrend : true) and htfAlignBuy and regimeOK
bool rawSell = bearCross and sellConf >= minConf and barFilter and (eUseTrend ? bearTrend : true) and htfAlignSell and regimeOK

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PERSISTENCE ENGINE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// varip = persists between ticks within the same bar.
// On historical bars varip behaves like var â†’ persistence is instant
// (historical data has only 1 "tick" per bar = bar close).
//
// LOGIC:
//   rawBuy=true tick 1 â†’ start counting
//   rawBuy=true tick 2 â†’ increment
//   rawBuy=false tick 3 â†’ RESET (signal was phantom)
//   rawBuy=true tick 4 â†’ start over
//   ...persists N ticks or T seconds â†’ CONFIRMED â†’ lock ON
//   Once locked â†’ stays ON for rest of bar regardless of ticks
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Tick counters (consecutive ticks where raw signal = true)
varip int  buyTickCount  = 0
varip int  sellTickCount = 0

// Time trackers (timestamp of first consecutive true tick)
varip int  buyFirstTime  = 0
varip int  sellFirstTime = 0

// Persistence lock: once confirmed, stays ON for the rest of the bar
varip bool buyPersisted  = false
varip bool sellPersisted = false

// Captured confidence at moment of persistence confirmation
varip float persistBuyConf  = 0.0
varip float persistSellConf = 0.0

// Reset everything at the start of each new bar
if barstate.isnew
    buyTickCount  := 0
    sellTickCount := 0
    buyFirstTime  := 0
    sellFirstTime := 0
    buyPersisted  := false
    sellPersisted := false
    persistBuyConf  := 0.0
    persistSellConf := 0.0

// â”€â”€ BUY persistence tracking â”€â”€
// CRITICAL: On historical bars, Pine only processes 1 tick per bar.
// Persistence by ticks/time would NEVER pass â†’ bypass on historical data.
// barstate.ishistory ensures all historical signals work identically to v6.2.
if rawBuy and not buyPersisted
    buyTickCount += 1
    if buyFirstTime == 0
        buyFirstTime := timenow
    // Check persistence threshold (bypassed on historical bars)
    bool historyPass = barstate.ishistory
    bool tickOK = persistMode == "Ticks" and buyTickCount >= persistTicks
    bool timeOK = persistMode == "Time"  and buyFirstTime > 0 and (timenow - buyFirstTime) >= persistSec * 1000
    bool offOK  = persistMode == "Off"
    if historyPass or tickOK or timeOK or offOK
        buyPersisted   := true
        persistBuyConf := buyConf
else if not rawBuy and not buyPersisted
    // Signal dropped before persistence â†’ full reset (phantom ignored)
    buyTickCount := 0
    buyFirstTime := 0
// (if buyPersisted=true, we don't touch anything â€” it's locked)

// â”€â”€ SELL persistence tracking â”€â”€
if rawSell and not sellPersisted
    sellTickCount += 1
    if sellFirstTime == 0
        sellFirstTime := timenow
    bool historyPass = barstate.ishistory
    bool tickOK = persistMode == "Ticks" and sellTickCount >= persistTicks
    bool timeOK = persistMode == "Time"  and sellFirstTime > 0 and (timenow - sellFirstTime) >= persistSec * 1000
    bool offOK  = persistMode == "Off"
    if historyPass or tickOK or timeOK or offOK
        sellPersisted   := true
        persistSellConf := sellConf
else if not rawSell and not sellPersisted
    sellTickCount := 0
    sellFirstTime := 0

// â”€â”€â”€ FINAL SIGNALS â”€â”€â”€
// On historical bars: varip behaves like var, barstate.ishistory
// ensures persistence is instant (no waiting on closed bars).
// On real-time bars: signal only activates after passing persistence.
bool buySignal  = buyPersisted
bool sellSignal = sellPersisted

// â”€â”€â”€ UPDATE COOLDOWN (ghost-proof) â”€â”€â”€
// Only update when signal has PASSED persistence.
// Phantom signals that die before threshold â†’ zero impact on cooldown.
if buyPersisted or sellPersisted
    lastSigBar_safe := bar_index


// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                     PRICE FORMAT HELPER                         â•‘
// â•‘  Auto-formats price based on magnitude for clean labels         â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

f_formatPrice(float p) =>
    string result = ""
    if p >= 10000
        result := str.tostring(p, "#")           // BTC: 98432
    else if p >= 100
        result := str.tostring(p, "#.#")          // ETH/SOL: 3421.5
    else if p >= 1
        result := str.tostring(p, "#.##")         // Mid-caps: 12.45
    else if p >= 0.01
        result := str.tostring(p, "#.####")       // Low: 0.1234
    else
        result := str.tostring(p, "#.######")     // Micro: 0.000123
    result


// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                     VISUALIZATION                               â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

grp_viz = "â•â•â•â•â•â• VISUALIZATION â•â•â•â•â•â•"
showITrend      = input.bool(true,  "Show iTrend",        group=grp_viz)
showCloud       = input.bool(true,  "Show Cloud",         group=grp_viz)
showBuySignals  = input.bool(true,  "Show BUY Signals",   group=grp_viz)
showSellSignals = input.bool(true,  "Show SELL Signals",  group=grp_viz)
showInfoTable   = input.bool(true,  "Show Info Table",    group=grp_viz)
showRegimeBG    = input.bool(true,  "Show Regime BG",     group=grp_viz,
     tooltip="Yellow background tint when regime filters detect ranging.\nHelps visualize when the system is paused.")
cloudAtrLen     = input.int(14,     "Cloud ATR Len",      group=grp_viz)
cloudAtrMult    = input.float(1.5,  "Cloud ATR Mult",     group=grp_viz)

color bullColor = #00C853
color bearColor = #FF1744

float atr = ta.atr(cloudAtrLen)
float cloudUpper = iTrend + atr * cloudAtrMult
float cloudLower = iTrend - atr * cloudAtrMult

plot(showITrend ? iTrend : na, "ITrend", color=bullTrend ? bullColor : bearColor, linewidth=2)
pU = plot(showCloud ? cloudUpper : na, "Cloud Upper", color=color.new(color.gray, 90))
pL = plot(showCloud ? cloudLower : na, "Cloud Lower", color=color.new(color.gray, 90))
pM = plot(showCloud ? iTrend : na, "Cloud Mid", color=na)
fill(pU, pM, color=bullTrend ? color.new(bullColor, 85) : color.new(bearColor, 85), title="Upper Fill")
fill(pM, pL, color=bullTrend ? color.new(bullColor, 85) : color.new(bearColor, 85), title="Lower Fill")

// â”€â”€â”€ REAL-TIME PRICE CAPTURE â”€â”€â”€
// Price captured at the moment persistence confirms (not before).
// This means the price is the actual price when the signal was deemed real.
varip float  capturedBuyPrice  = na
varip float  capturedSellPrice = na
varip bool   buyPriceCaptured  = false
varip bool   sellPriceCaptured = false

if barstate.isnew
    capturedBuyPrice  := na
    capturedSellPrice := na
    buyPriceCaptured  := false
    sellPriceCaptured := false

// Capture price at moment of persistence confirmation
if buyPersisted and not buyPriceCaptured
    capturedBuyPrice := barstate.ishistory ? srcCyber : close
    buyPriceCaptured := true

if sellPersisted and not sellPriceCaptured
    capturedSellPrice := barstate.ishistory ? srcCyber : close
    sellPriceCaptured := true

// â”€â”€â”€ SIGNAL LABELS â”€â”€â”€
if showBuySignals and buySignal
    float displayPrice = not na(capturedBuyPrice) ? capturedBuyPrice : srcCyber
    string priceStr = f_formatPrice(displayPrice)
    string liveTag  = barstate.isrealtime ? " â—" : ""
    label.new(bar_index, low, "BUY\n" + priceStr + liveTag, 
         style=label.style_label_up, color=bullColor, textcolor=color.white, size=size.normal)

if showSellSignals and sellSignal
    float displayPrice = not na(capturedSellPrice) ? capturedSellPrice : srcCyber
    string priceStr = f_formatPrice(displayPrice)
    string liveTag  = barstate.isrealtime ? " â—" : ""
    label.new(bar_index, high, "SELL\n" + priceStr + liveTag, 
         style=label.style_label_down, color=bearColor, textcolor=color.white, size=size.normal)

// â”€â”€â”€ WEAK SIGNALS â”€â”€â”€
bool weakBuy = bullCross and buyConf >= 30 and buyConf < minConf and barFilter and htfAlignBuy and regimeOK
bool weakSell = bearCross and sellConf >= 30 and sellConf < minConf and barFilter and htfAlignSell and regimeOK
plotshape(showBuySignals and weakBuy, "Weak Buy", shape.circle, location.belowbar, color.new(bullColor, 50), size=size.tiny)
plotshape(showSellSignals and weakSell, "Weak Sell", shape.circle, location.abovebar, color.new(bearColor, 50), size=size.tiny)
barcolor(cyberCycle > trigger and bullTrend ? bullColor : cyberCycle < trigger and bearTrend ? bearColor : na)

// â”€â”€â”€ REGIME BACKGROUND (subtle warning when ranging) â”€â”€â”€
color regimeBG = showRegimeBG and not regimeOK ? color.new(color.yellow, 92) : na
bgcolor(regimeBG, title="Regime Warning", editable=true)


// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                     INFO TABLE                                  â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if showInfoTable and barstate.islast
    var table t = table.new(position.top_right, 2, 16, bgcolor=color.new(color.black, 70), border_width=1, border_color=color.gray)
    int row = 0

    table.cell(t, 0, row, "Method", text_color=color.white, text_size=size.small)
    table.cell(t, 1, row, eAlphaMethod + "  Î±=" + str.tostring(adaptiveAlpha, "#.###") + "  P=" + str.tostring(dominantPeriod, "#.#"), text_color=color.yellow, text_size=size.small)
    row += 1
    table.cell(t, 0, row, "Coin", text_color=color.white, text_size=size.small)
    table.cell(t, 1, row, detectedCoin + (eAFloor > 0 ? "  floor=" + str.tostring(eAFloor, "#.##") : "") + "  iT=" + str.tostring(eITrendAlpha, "#.##"), text_color=color.yellow, text_size=size.small)
    row += 1
    table.cell(t, 0, row, "Cycle", text_color=color.white, text_size=size.small)
    table.cell(t, 1, row, str.tostring(cyberCycle, "#.####"), text_color=cyberCycle > 0 ? bullColor : bearColor, text_size=size.small)
    row += 1
    table.cell(t, 0, row, "Trend", text_color=color.white, text_size=size.small)
    table.cell(t, 1, row, (bullTrend ? "BULL" : bearTrend ? "BEAR" : "FLAT") + (eUseTrend ? "" : " [OFF]"), text_color=bullTrend ? bullColor : bearTrend ? bearColor : color.gray, text_size=size.small)
    row += 1
    table.cell(t, 0, row, "Zone", text_color=color.white, text_size=size.small)
    table.cell(t, 1, row, inOB ? "OVERBOUGHT" : inOS ? "OVERSOLD" : "NEUTRAL", text_color=inOB ? bearColor : inOS ? bullColor : color.gray, text_size=size.small)
    row += 1
    table.cell(t, 0, row, "Direction", text_color=color.white, text_size=size.small)
    table.cell(t, 1, row, cyberCycle > trigger ? "BULLISH" : "BEARISH", text_color=cyberCycle > trigger ? bullColor : bearColor, text_size=size.small)
    row += 1
    float cConf = buyPersisted ? persistBuyConf : sellPersisted ? persistSellConf : (bullCross ? buyConf : bearCross ? sellConf : 0)
    table.cell(t, 0, row, "Confidence", text_color=color.white, text_size=size.small)
    table.cell(t, 1, row, cConf > 0 ? str.tostring(cConf, "#") + "% (min " + str.tostring(minConf, "#") + "%)" + (buyPersisted or sellPersisted ? " âœ“" : "") : "---", text_color=cConf >= minConf ? bullColor : cConf >= 30 ? color.yellow : color.gray, text_size=size.small)
    row += 1
    table.cell(t, 0, row, eUseVol ? "Volume" : "Vol [OFF]", text_color=color.white, text_size=size.small)
    table.cell(t, 1, row, eUseVol ? (volumeOK ? "OK" : "LOW") : "---", text_color=volumeOK ? bullColor : color.gray, text_size=size.small)
    row += 1
    table.cell(t, 0, row, eUseHTF ? "HTF 4H" : "HTF [OFF]", text_color=color.white, text_size=size.small)
    table.cell(t, 1, row, eUseHTF ? (htfBullish ? "BULL" : "BEAR") : "---", text_color=htfBullish ? bullColor : bearColor, text_size=size.small)
    row += 1

    // Signal persistence + cooldown status
    int barsSinceSig = bar_index - lastSigBar_safe
    string coolStr = barsSinceSig < eMinBars ? "COOL " + str.tostring(eMinBars - barsSinceSig) + "b" : "READY"
    string persStr = persistMode == "Time" ? str.tostring(persistSec, "#") + "s" : persistMode == "Ticks" ? str.tostring(persistTicks) + "t" : "OFF"
    string lockStr = buyPersisted ? " BUYâœ“" : sellPersisted ? " SELLâœ“" : rawBuy ? " BUYâ³" + str.tostring(buyTickCount) : rawSell ? " SELLâ³" + str.tostring(sellTickCount) : ""
    table.cell(t, 0, row, "Signal", text_color=color.white, text_size=size.small)
    table.cell(t, 1, row, "P:" + persStr + "  " + coolStr + lockStr, text_color=barsSinceSig < eMinBars ? color.yellow : bullColor, text_size=size.small)
    row += 1

    // â”€â”€â”€ REGIME FILTERS STATUS â”€â”€â”€
    string regimeStr = regimeOK ? "TRENDING" : "RANGING"
    string regimeDet = str.tostring(regimePassCount) + "/" + str.tostring(regimeActiveCount) + " pass"
    color  regimeCol = regimeOK ? bullColor : color.yellow
    table.cell(t, 0, row, "Regime", text_color=color.white, text_size=size.small)
    table.cell(t, 1, row, regimeActiveCount > 0 ? regimeStr + "  " + regimeDet : "ALL OFF", text_color=regimeActiveCount > 0 ? regimeCol : color.gray, text_size=size.small)
    row += 1

    // Individual filter details (compact single row)
    string fDet = ""
    fDet += useAmpFilter ? ("Amp:" + (ampOK ? "âœ“" : "âœ—") + str.tostring(ampRatio, "#.##") + " ") : ""
    fDet += useSqueeze   ? ("Sqz:" + (sqzOK ? "âœ“" : "âœ—") + " ") : ""
    fDet += useADX       ? ("ADX:" + (adxOK ? "âœ“" : "âœ—") + str.tostring(adxValue, "#.#") + " ") : ""
    fDet += useCycleStr  ? ("Cyc:" + (cycleStrOK ? "âœ“" : "âœ—") + str.tostring(_ac_peakCorr, "#.##") + " ") : ""
    fDet += useSNR       ? ("SNR:" + (snrOK ? "âœ“" : "âœ—") + str.tostring(snrDB, "#.#") + "dB") : ""
    table.cell(t, 0, row, "Filters", text_color=color.white, text_size=size.small)
    table.cell(t, 1, row, fDet != "" ? fDet : "none active", text_color=regimeOK ? color.gray : color.yellow, text_size=size.tiny)
    row += 1

    table.cell(t, 0, row, "Config", text_color=color.white, text_size=size.small)
    table.cell(t, 1, row, "T=" + str.tostring(eTrigEma) + " B=" + str.tostring(eMinBars) + " OB=" + str.tostring(eOB, "#.#") + " OS=" + str.tostring(eOS, "#.#"), text_color=color.white, text_size=size.small)
    row += 1
    // All alpha methods running for transparency
    table.cell(t, 0, row, "All Î±", text_color=color.white, text_size=size.small)
    table.cell(t, 1, row, "HD=" + str.tostring(_a_hd, "#.###") + " MA=" + str.tostring(_a_ma, "#.###") + " AC=" + str.tostring(_a_ac, "#.###") + " KL=" + str.tostring(_a_kl, "#.###"), text_color=color.gray, text_size=size.small)


// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘                     ALERTS                                      â•‘
// â•‘  v7.1: Alerts fire ONLY after persistence is confirmed.          â•‘
// â•‘  Phantom signals that die before threshold â†’ no alert.          â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

alertcondition(buySignal, "Buy v7.1", "CC v7.1: BUY Signal (persisted, regime OK)")
alertcondition(sellSignal, "Sell v7.1", "CC v7.1: SELL Signal (persisted, regime OK)")
alertcondition(bullCross, "Bull Cross", "CC v7.1: Bull Cross (unfiltered)")
alertcondition(bearCross, "Bear Cross", "CC v7.1: Bear Cross (unfiltered)")
alertcondition(not regimeOK and regimeOK[1], "Regime â†’ RANGING", "CC v7.1: Market entered RANGING regime")
alertcondition(regimeOK and not regimeOK[1], "Regime â†’ TRENDING", "CC v7.1: Market returned to TRENDING regime")
