//@version=5
// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘   SMC PURE OSCILLATOR                               â•‘
// â•‘   v7.3                                                               â•‘
// â•‘                                                                      â•‘
// â•‘  FIX vs v7.2:                                                        â•‘
// â•‘   ğŸ”´ EDGE DETECTION: todos los eventos HTF y locales ahora        â•‘
// â•‘      usan detecciÃ³n de flanco (rising edge). El label aparece     â•‘
// â•‘      UNA sola vez, no se repite mientras request.security = true. â•‘
// â•‘   ğŸ”´ SEÃ‘ALES EN CHART: L2 y L3 se plotean tambiÃ©n sobre el       â•‘
// â•‘      grÃ¡fico principal con force_overlay.                          â•‘
// â•‘   ğŸ”´ VISUAL MEJORADO: diseÃ±o mÃ¡s limpio de seÃ±ales.              â•‘
// â•‘                                                                      â•‘
// â•‘  Arquitectura (sin cambios):                                        â•‘
// â•‘   Oscilador = TF actual (PositionÃ—60% + OB ProxÃ—40%)             â•‘
// â•‘   HTFs = solo filtro de trend para L2/L3                           â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
indicator("SMC Pure Oscillator",
     shorttitle       = "SMCÂ·PURE",
     overlay          = false,
     max_labels_count = 200)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HTF AUTO-RELATIVO
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
f_auto_htf() =>
    int sec = timeframe.in_seconds()
    string h1 = ""
    string h2 = ""
    if sec <= 300
        h1 := "15"
        h2 := "60"
    else if sec <= 900
        h1 := "60"
        h2 := "240"
    else if sec <= 2700
        h1 := "120"
        h2 := "480"
    else if sec <= 3600
        h1 := "240"
        h2 := "1D"
    else if sec <= 7200
        h1 := "480"
        h2 := "1D"
    else if sec <= 14400
        h1 := "1D"
        h2 := "1W"
    else if sec <= 86400
        h1 := "1W"
        h2 := "1M"
    else
        h1 := "1M"
        h2 := "3M"
    [h1, h2]

[auto_htf1, auto_htf2] = f_auto_htf()

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INPUTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grp_s   = "âš™ï¸  Estructura SMC"
grp_htf = "ğŸ• HTF Filtro (solo trend)"
grp_fus = "ğŸ”— FusiÃ³n"
grp_sig = "ğŸ¯ SeÃ±ales"
grp_vis = "ğŸ‘ Visual"
grp_c   = "ğŸ¨ Colores"

int  swingLen   = input.int (5,    "Swing Length",  minval=2, maxval=15, group=grp_s)
bool useSweep   = input.bool(true, "Sweeps",                             group=grp_s)
int  obLookback = input.int (5,    "OB Lookback",   minval=2, maxval=20, group=grp_s)

bool   htf_en   = input.bool (true, "Activar Filtro HTF",                group=grp_htf)
string htf_mode = input.string("1 HTF", "HTFs requeridos",               group=grp_htf,
     options=["1 HTF", "2 HTFs"],
     tooltip="1 HTF: solo HTF Medio debe confirmar.\n2 HTFs: ambos (Medio + Alto) deben confirmar.\n1 HTF es menos restrictivo â†’ mÃ¡s seÃ±ales L2/L3.")
bool   htf_auto = input.bool (true, "Auto-Detectar HTFs",                group=grp_htf)
string htf1_man = input.timeframe("1D", "HTF Medio (manual)",            group=grp_htf)
string htf2_man = input.timeframe("1W", "HTF Alto (manual)",             group=grp_htf)

float  wA       = input.float(0.6, "Peso Capa A (Position)", minval=0.0, maxval=1.0, step=0.05, group=grp_fus)
float  wB       = input.float(0.4, "Peso Capa B (OB Prox)",  minval=0.0, maxval=1.0, step=0.05, group=grp_fus)
int    smoothL  = input.int  (5,   "Suavizado EMA",           minval=1, maxval=30, group=grp_fus)
int    trigL    = input.int  (8,   "Trigger EMA",              minval=2, maxval=30, group=grp_fus)

int   eventWin  = input.int (5,  "Event Window",   minval=1,  maxval=20, group=grp_sig)
int   sigCool   = input.int (5,  "Signal Cooldown", minval=1, maxval=30, group=grp_sig,
     tooltip="MÃ­nimo de barras entre seÃ±ales del mismo tipo.")
bool  showL1    = input.bool(false,"L1: Cruce Main/Trig",               group=grp_sig)
bool  showL2    = input.bool(true, "L2: Cruce + HTF trend",             group=grp_sig)
bool  showL3    = input.bool(true, "L3: Cruce + HTF + evento SMC",      group=grp_sig)
bool  showChart = input.bool(true, "SeÃ±ales en Chart",                  group=grp_sig,
     tooltip="Muestra L2/L3 sobre el grÃ¡fico de precio.")
bool  showEvOsc = input.bool(true, "Eventos en Oscilador",              group=grp_sig)

bool showHist   = input.bool(true,  "Histograma",               group=grp_vis)
bool showTrig   = input.bool(true,  "Trigger Line",             group=grp_vis)
bool showCapaA  = input.bool(false, "Capa A: Position (diag)",  group=grp_vis)
bool showCapaB  = input.bool(false, "Capa B: OB Prox (diag)",   group=grp_vis)
bool showTable  = input.bool(true,  "Tabla Estado",             group=grp_vis)

color bullCol  = input.color(#089981, "Alcista",  group=grp_c)
color bearCol  = input.color(#f23645, "Bajista",  group=grp_c)
color sweepCol = input.color(#f0b429, "Sweep",    group=grp_c)
color trigCol  = input.color(color.new(#ffffff, 45), "Trigger", group=grp_c)

string htf1 = htf_auto ? auto_htf1 : htf1_man
string htf2 = htf_auto ? auto_htf2 : htf2_man

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MÃQUINA SMC COMPLETA
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
f_smc_full(int swing_len, bool use_sweep, int ob_lb) =>
    float ph = ta.pivothigh(high, swing_len, swing_len)
    float pl = ta.pivotlow (low,  swing_len, swing_len)
    var float last_ph = na
    var float last_pl = na
    if not na(ph)
        last_ph := ph
    if not na(pl)
        last_pl := pl

    var int   ms_trend = 1
    var float ms_bos   = na
    var float ms_choch = na
    var float ms_main  = high
    bool ev_cb = false
    bool ev_cr = false
    bool ev_bb = false
    bool ev_br = false
    bool ev_su = false
    bool ev_sd = false

    if ms_trend == 1
        if high > nz(ms_main, high)
            ms_main := high
        bool cdn = close < open and close[1] < open[1]
        if na(ms_bos) and cdn
            ms_bos := ms_main
        if use_sweep and not na(ms_choch)
            if low <= ms_choch and close > ms_choch
                ev_sd    := true
                ms_choch := low
        if use_sweep and not na(ms_bos)
            if high >= ms_bos and close < ms_bos
                ev_su  := true
                ms_bos := high
        if not na(ms_bos) and close >= ms_bos
            ev_bb    := true
            ms_choch := not na(last_pl) ? last_pl : ms_main * 0.99
            ms_bos   := na
            ms_main  := high
        if not na(ms_choch) and close <= ms_choch
            ev_cr    := true
            ms_trend := -1
            ms_choch := not na(last_ph) ? last_ph : ms_main
            ms_main  := low
            ms_bos   := na

    if ms_trend == -1
        if low < nz(ms_main, low)
            ms_main := low
        bool cup = close > open and close[1] > open[1]
        if na(ms_bos) and cup
            ms_bos := ms_main
        if use_sweep and not na(ms_choch)
            if high >= ms_choch and close < ms_choch
                ev_su    := true
                ms_choch := high
        if use_sweep and not na(ms_bos)
            if low <= ms_bos and close > ms_bos
                ev_sd  := true
                ms_bos := low
        if not na(ms_bos) and close <= ms_bos
            ev_br    := true
            ms_choch := not na(last_ph) ? last_ph : ms_main * 1.01
            ms_bos   := na
            ms_main  := low
        if not na(ms_choch) and close >= ms_choch
            ev_cb    := true
            ms_trend := 1
            ms_choch := not na(last_pl) ? last_pl : ms_main
            ms_main  := high
            ms_bos   := na

    // Order Blocks
    var float bull_ob_top = na
    var float bull_ob_btm = na
    var float bear_ob_top = na
    var float bear_ob_btm = na
    if ev_bb or ev_cb
        for i = 1 to ob_lb
            if close[i] < open[i]
                bull_ob_top := high[i]
                bull_ob_btm := low [i]
                break
    if ev_br or ev_cr
        for i = 1 to ob_lb
            if close[i] > open[i]
                bear_ob_top := high[i]
                bear_ob_btm := low [i]
                break
    if not na(bull_ob_btm) and low  < bull_ob_btm
        bull_ob_top := na
        bull_ob_btm := na
    if not na(bear_ob_top) and high > bear_ob_top
        bear_ob_top := na
        bear_ob_btm := na

    // Capa A â€” Structural Position
    float struct_pos = 0.0
    float _choch = nz(ms_choch, close)
    float _main  = nz(ms_main,  close)
    float _range = math.abs(_main - _choch)
    float _atr   = ta.atr(14)
    float safe_range = math.max(_range, _atr * 0.5)
    if ms_trend == 1
        float raw_pos = (close - _choch) / safe_range
        struct_pos := math.max(-1.5, math.min(1.5, raw_pos)) * 100.0
    else
        float raw_pos = (_choch - close) / safe_range
        struct_pos := math.max(-1.5, math.min(1.5, raw_pos)) * -100.0

    // Capa B â€” OB Proximity (trend-aware v7.2)
    float ob_pressure = 0.0
    float safe_atr = math.max(_atr, 0.0001)
    bool has_bull_ob = not na(bull_ob_btm) and not na(bull_ob_top)
    bool has_bear_ob = not na(bear_ob_btm) and not na(bear_ob_top)
    if has_bull_ob and has_bear_ob
        float bull_mid = math.avg(bull_ob_top, bull_ob_btm)
        float bear_mid = math.avg(bear_ob_top, bear_ob_btm)
        float dist_bull = math.abs(close - bull_mid) / safe_atr
        float dist_bear = math.abs(close - bear_mid) / safe_atr
        float total = dist_bull + dist_bear
        if total > 0.001
            ob_pressure := ((dist_bear - dist_bull) / total) * 100.0
        if close >= bull_ob_btm and close <= bull_ob_top
            ob_pressure := math.max(ob_pressure, 50.0)
        if close >= bear_ob_btm and close <= bear_ob_top
            ob_pressure := math.min(ob_pressure, -50.0)
    else if has_bull_ob and not has_bear_ob
        float bull_mid = math.avg(bull_ob_top, bull_ob_btm)
        float dist = math.abs(close - bull_mid) / safe_atr
        float proximity = math.max(0.0, 1.0 - dist / 5.0)
        if ms_trend == 1
            ob_pressure := proximity * 30.0
            if close >= bull_ob_btm and close <= bull_ob_top
                ob_pressure := 40.0
        else
            ob_pressure := proximity * 15.0 - 15.0
            if close >= bull_ob_btm and close <= bull_ob_top
                ob_pressure := 20.0
    else if has_bear_ob and not has_bull_ob
        float bear_mid = math.avg(bear_ob_top, bear_ob_btm)
        float dist = math.abs(close - bear_mid) / safe_atr
        float proximity = math.max(0.0, 1.0 - dist / 5.0)
        if ms_trend == -1
            ob_pressure := -proximity * 30.0
            if close >= bear_ob_btm and close <= bear_ob_top
                ob_pressure := -40.0
        else
            ob_pressure := -proximity * 15.0 + 15.0
            if close >= bear_ob_btm and close <= bear_ob_top
                ob_pressure := -20.0

    struct_pos  := math.max(-100.0, math.min(100.0, struct_pos))
    ob_pressure := math.max(-100.0, math.min(100.0, ob_pressure))
    [struct_pos, ob_pressure, ms_trend, ev_cb, ev_cr, ev_bb, ev_br, ev_su, ev_sd]

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FUNCIÃ“N LIGERA SOLO TREND (HTFs)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
f_smc_trend(int swing_len, bool use_sweep) =>
    float ph = ta.pivothigh(high, swing_len, swing_len)
    float pl = ta.pivotlow (low,  swing_len, swing_len)
    var float last_ph = na
    var float last_pl = na
    if not na(ph)
        last_ph := ph
    if not na(pl)
        last_pl := pl
    var int   ms_trend = 1
    var float ms_bos   = na
    var float ms_choch = na
    var float ms_main  = high
    bool ev_cb = false
    bool ev_cr = false
    if ms_trend == 1
        if high > nz(ms_main, high)
            ms_main := high
        bool cdn = close < open and close[1] < open[1]
        if na(ms_bos) and cdn
            ms_bos := ms_main
        if use_sweep and not na(ms_choch)
            if low <= ms_choch and close > ms_choch
                ms_choch := low
        if use_sweep and not na(ms_bos)
            if high >= ms_bos and close < ms_bos
                ms_bos := high
        if not na(ms_bos) and close >= ms_bos
            ms_choch := not na(last_pl) ? last_pl : ms_main * 0.99
            ms_bos   := na
            ms_main  := high
        if not na(ms_choch) and close <= ms_choch
            ev_cr    := true
            ms_trend := -1
            ms_choch := not na(last_ph) ? last_ph : ms_main
            ms_main  := low
            ms_bos   := na
    if ms_trend == -1
        if low < nz(ms_main, low)
            ms_main := low
        bool cup = close > open and close[1] > open[1]
        if na(ms_bos) and cup
            ms_bos := ms_main
        if use_sweep and not na(ms_choch)
            if high >= ms_choch and close < ms_choch
                ms_choch := high
        if use_sweep and not na(ms_bos)
            if low <= ms_bos and close > ms_bos
                ms_bos := low
        if not na(ms_bos) and close <= ms_bos
            ms_choch := not na(last_ph) ? last_ph : ms_main * 1.01
            ms_bos   := na
            ms_main  := low
        if not na(ms_choch) and close >= ms_choch
            ev_cb    := true
            ms_trend := 1
            ms_choch := not na(last_pl) ? last_pl : ms_main
            ms_main  := high
            ms_bos   := na
    [ms_trend, ev_cb, ev_cr]

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// EJECUCIÃ“N
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
[posA0, obP0, tr0, cb0, cr0, bb0, br0, su0, sd0] = f_smc_full(swingLen, useSweep, obLookback)
[tr1, cb1, cr1] = request.security(syminfo.tickerid, htf1, f_smc_trend(swingLen, useSweep), lookahead=barmerge.lookahead_off)
[tr2, cb2, cr2] = request.security(syminfo.tickerid, htf2, f_smc_trend(swingLen, useSweep), lookahead=barmerge.lookahead_off)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// OSCILADOR
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
float wt = wA + wB
float raw_osc = wt > 0 ? (posA0 * wA + obP0 * wB) / wt : posA0
float raw_clamped = math.max(-100.0, math.min(100.0, raw_osc))
float smc_main = ta.ema(raw_clamped, smoothL)
float smc_trig = ta.ema(raw_clamped, trigL)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// EDGE DETECTION â€” TODOS LOS EVENTOS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HTF: request.security mantiene true durante varias barras del TF actual.
// Edge = true SOLO en la primera barra donde cambia de false a true.
bool htf_cb1_edge = cb1 and not nz(cb1[1], false)
bool htf_cr1_edge = cr1 and not nz(cr1[1], false)
bool htf_cb2_edge = cb2 and not nz(cb2[1], false)
bool htf_cr2_edge = cr2 and not nz(cr2[1], false)
bool htf_choch_b  = htf_cb1_edge or htf_cb2_edge
bool htf_choch_r  = htf_cr1_edge or htf_cr2_edge

// TF actual: eventos ya son single-bar por diseÃ±o, pero aplicamos cooldown
bool ev_choch_bull = cb0
bool ev_choch_bear = cr0
bool ev_bos_bull   = bb0
bool ev_bos_bear   = br0
bool ev_sweep_up   = su0
bool ev_sweep_dn   = sd0

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SEÃ‘ALES CON COOLDOWN
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
bool htf_bull   = not htf_en ? true : htf_mode == "2 HTFs" ? (tr1 == 1  and tr2 == 1)  : (tr1 == 1)
bool htf_bear   = not htf_en ? true : htf_mode == "2 HTFs" ? (tr1 == -1 and tr2 == -1) : (tr1 == -1)
bool align_bull = tr0 == 1  and htf_bull
bool align_bear = tr0 == -1 and htf_bear

bool bull_cross = ta.crossover (smc_main, smc_trig)
bool bear_cross = ta.crossunder(smc_main, smc_trig)

int bs_bull = ta.barssince(ev_choch_bull or ev_bos_bull)
int bs_bear = ta.barssince(ev_choch_bear or ev_bos_bear)
bool recent_bull_ev = not na(bs_bull) and bs_bull <= eventWin
bool recent_bear_ev = not na(bs_bear) and bs_bear <= eventWin

bool raw_L1_long  = bull_cross
bool raw_L1_short = bear_cross
bool raw_L2_long  = bull_cross and htf_bull
bool raw_L2_short = bear_cross and htf_bear
bool raw_L3_long  = raw_L2_long  and recent_bull_ev
bool raw_L3_short = raw_L2_short and recent_bear_ev

// Cooldown tracker
var int cd_L1l = 999
var int cd_L1s = 999
var int cd_L2l = 999
var int cd_L2s = 999
var int cd_L3l = 999
var int cd_L3s = 999
cd_L1l += 1
cd_L1s += 1
cd_L2l += 1
cd_L2s += 1
cd_L3l += 1
cd_L3s += 1

bool sig_L1_long  = raw_L1_long  and cd_L1l > sigCool
bool sig_L1_short = raw_L1_short and cd_L1s > sigCool
bool sig_L2_long  = raw_L2_long  and cd_L2l > sigCool
bool sig_L2_short = raw_L2_short and cd_L2s > sigCool
bool sig_L3_long  = raw_L3_long  and cd_L3l > sigCool
bool sig_L3_short = raw_L3_short and cd_L3s > sigCool

if sig_L1_long
    cd_L1l := 0
if sig_L1_short
    cd_L1s := 0
if sig_L2_long
    cd_L2l := 0
if sig_L2_short
    cd_L2s := 0
if sig_L3_long
    cd_L3l := 0
if sig_L3_short
    cd_L3s := 0

bool cross_bull_zero = ta.crossover (smc_main, 0)
bool cross_bear_zero = ta.crossunder(smc_main, 0)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PLOTTING â€” OSCILADOR  (optimizado: â‰¤40 outputs)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Zonas                                                          // 5 hline + 2 fill = 7
h0 = hline(  0,  "Cero",   color.new(color.gray, 50), linestyle=hline.style_solid,  linewidth=1)
h1 = hline( 50,  "OB",     color.new(bearCol,    70), linestyle=hline.style_dashed, linewidth=1)
h2 = hline(-50,  "OS",     color.new(bullCol,    70), linestyle=hline.style_dashed, linewidth=1)
h3 = hline( 80,  "Ext OB", color.new(bearCol,    80), linestyle=hline.style_dotted)
h4 = hline(-80,  "Ext OS", color.new(bullCol,    80), linestyle=hline.style_dotted)
fill(h1, h3, color=color.new(bearCol, 94), title="Zona OB")
fill(h2, h4, color=color.new(bullCol, 94), title="Zona OS")

// LÃ­neas principales                                             // 5 plot = 5
bool mom_rising = smc_main > nz(smc_main[1])
color hist_col = smc_main >= 0 ? (mom_rising ? bullCol : color.new(bullCol, 55)) : (mom_rising ? color.new(bearCol, 55) : bearCol)
plot(showHist ? smc_main : na, "Histograma", color=hist_col, style=plot.style_columns, linewidth=3)
color main_col = smc_main >= smc_trig ? bullCol : bearCol
plot(smc_main, "SMC Main", color=main_col, linewidth=2)
plot(showTrig ? smc_trig : na, "Trigger", color=trigCol, linewidth=1)
plot(showCapaA ? posA0 : na, "Capa A", color=color.new(color.aqua, 40), linewidth=1)
plot(showCapaB ? obP0  : na, "Capa B", color=color.new(color.orange, 40), linewidth=1)

// Background trend (1 bgcolor combinado)                         // 1 bgcolor
color trend_bg = align_bull ? color.new(bullCol, 93) : align_bear ? color.new(bearCol, 93) : na
bgcolor(trend_bg, title="Trend BG")

// Eventos en oscilador (6 plotshape)                             // 6 plotshape
plotshape(showEvOsc and htf_choch_b, "HTF Câ–²", shape.labelup,   location.bottom, color.new(bullCol, 0), text="CÂ·H", textcolor=color.white, size=size.small)
plotshape(showEvOsc and htf_choch_r, "HTF Câ–¼", shape.labeldown,  location.top,    color.new(bearCol, 0), text="CÂ·H", textcolor=color.white, size=size.small)
plotshape(showEvOsc and ev_choch_bull, "CHoCHâ–²", shape.diamond, location.bottom, color.new(bullCol, 10), size=size.tiny)
plotshape(showEvOsc and ev_choch_bear, "CHoCHâ–¼", shape.diamond, location.top,    color.new(bearCol, 10), size=size.tiny)
plotshape(showEvOsc and (ev_bos_bull or ev_sweep_dn), "BOS/Swâ–²", shape.triangleup,   location.bottom, color.new(bullCol, 30), size=size.tiny)
plotshape(showEvOsc and (ev_bos_bear or ev_sweep_up), "BOS/Swâ–¼", shape.triangledown, location.top,    color.new(bearCol, 30), size=size.tiny)

// SeÃ±ales en oscilador (4 plotshape: solo L2 y L3)              // 4 plotshape
plotshape(showL2 and sig_L2_long  and not sig_L3_long,  "L2â–²", shape.triangleup,   location.bottom, color.new(bullCol, 10), size=size.small)
plotshape(showL2 and sig_L2_short and not sig_L3_short, "L2â–¼", shape.triangledown, location.top,    color.new(bearCol, 10), size=size.small)
plotshape(showL3 and sig_L3_long,  "L3â–²", shape.labelup,   location.bottom, color.new(bullCol, 0), text="â–²", textcolor=color.white, size=size.normal)
plotshape(showL3 and sig_L3_short, "L3â–¼", shape.labeldown, location.top,    color.new(bearCol, 0), text="â–¼", textcolor=color.white, size=size.normal)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PLOTTING â€” CHART PRINCIPAL (force_overlay)                     // 8 plotshape
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// L1 en chart (triÃ¡ngulos tiny semitransparentes)
plotshape(showChart and showL1 and sig_L1_long and not sig_L2_long,
     "Chart L1â–²", shape.triangleup, location.belowbar,
     color.new(bullCol, 50), size=size.tiny, force_overlay=true)
plotshape(showChart and showL1 and sig_L1_short and not sig_L2_short,
     "Chart L1â–¼", shape.triangledown, location.abovebar,
     color.new(bearCol, 50), size=size.tiny, force_overlay=true)
// L2 en chart (triÃ¡ngulos small)
plotshape(showChart and showL2 and sig_L2_long and not sig_L3_long,
     "Chart L2â–²", shape.triangleup, location.belowbar,
     color.new(bullCol, 10), size=size.small, force_overlay=true)
plotshape(showChart and showL2 and sig_L2_short and not sig_L3_short,
     "Chart L2â–¼", shape.triangledown, location.abovebar,
     color.new(bearCol, 10), size=size.small, force_overlay=true)
// L3 en chart (labels LONG/SHORT)
plotshape(showChart and showL3 and sig_L3_long,
     "Chart L3â–²", shape.labelup, location.belowbar,
     color.new(bullCol, 0), text="LONG", textcolor=color.white, size=size.normal, force_overlay=true)
plotshape(showChart and showL3 and sig_L3_short,
     "Chart L3â–¼", shape.labeldown, location.abovebar,
     color.new(bearCol, 0), text="SHORT", textcolor=color.white, size=size.normal, force_overlay=true)
// Eventos SMC en chart (CHoCH + BOS)
plotshape(showChart and showEvOsc and (ev_choch_bull or ev_bos_bull),
     "Chart Evâ–²", shape.diamond, location.belowbar,
     color.new(bullCol, 10), size=size.tiny, force_overlay=true)
plotshape(showChart and showEvOsc and (ev_choch_bear or ev_bos_bear),
     "Chart Evâ–¼", shape.diamond, location.abovebar,
     color.new(bearCol, 10), size=size.tiny, force_overlay=true)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TABLA
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
if showTable and barstate.islast
    var table t = table.new(position.top_right, 3, 7, bgcolor=color.new(#1a1a2e, 15), border_width=1, border_color=color.new(color.gray, 70))

    table.cell(t, 0, 0, "SMCÂ·PURE", bgcolor=color.new(#16213e, 0), text_color=color.white, text_size=size.small)
    table.cell(t, 1, 0, "TF:" + timeframe.period, bgcolor=color.new(#16213e, 0), text_color=color.gray, text_size=size.tiny)
    table.cell(t, 2, 0, htf1 + "/" + htf2, bgcolor=color.new(#16213e, 0), text_color=color.gray, text_size=size.tiny)

    string ft_badge = smc_main > smc_trig ? " â–²" : " â–¼"
    color  ft_col   = smc_main > smc_trig ? bullCol : bearCol
    table.cell(t, 0, 1, "Main", text_color=color.gray, text_size=size.small)
    table.cell(t, 1, 1, str.tostring(math.round(smc_main, 1)) + ft_badge, text_color=ft_col, text_size=size.small)
    table.cell(t, 2, 1, "T:" + str.tostring(math.round(smc_trig, 1)), text_color=color.new(color.white, 40), text_size=size.tiny)

    table.cell(t, 0, 2, "Position", text_color=color.gray, text_size=size.small)
    table.cell(t, 1, 2, str.tostring(math.round(posA0, 1)), text_color=posA0 >= 0 ? bullCol : bearCol, text_size=size.small)
    table.cell(t, 2, 2, str.tostring(math.round(wA * 100, 0)) + "%", text_color=color.gray, text_size=size.tiny)

    table.cell(t, 0, 3, "OB Prox", text_color=color.gray, text_size=size.small)
    table.cell(t, 1, 3, str.tostring(math.round(obP0, 1)), text_color=obP0 >= 0 ? bullCol : bearCol, text_size=size.small)
    table.cell(t, 2, 3, str.tostring(math.round(wB * 100, 0)) + "%", text_color=color.gray, text_size=size.tiny)

    string tr0_s = tr0 == 1 ? "â–²" : "â–¼"
    string tr1_s = htf_en ? (tr1 == 1 ? "â–²" : "â–¼") : "â€”"
    string tr2_s = htf_en and htf_mode == "2 HTFs" ? (tr2 == 1 ? "â–²" : "â–¼") : "â€”"
    string htf_str = tr0_s + " " + tr1_s + " " + tr2_s
    string aln_str = align_bull ? "  FULL BULL" : align_bear ? "  FULL BEAR" : ""
    color  htf_col = align_bull ? bullCol : align_bear ? bearCol : color.yellow
    table.cell(t, 0, 4, "Trend", text_color=color.gray, text_size=size.small)
    table.cell(t, 1, 4, htf_str + aln_str, text_color=htf_col, text_size=size.small)
    table.cell(t, 2, 4, htf_mode, text_color=color.gray, text_size=size.tiny)

    string lev = ev_choch_bull?"CHoCH â–²":ev_choch_bear?"CHoCH â–¼":ev_bos_bull?"BOS â–²":ev_bos_bear?"BOS â–¼":ev_sweep_dn?"Sweep â–¼":ev_sweep_up?"Sweep â–²":htf_choch_b?"HTF Câ–²":htf_choch_r?"HTF Câ–¼":"â€”"
    color  lec = ev_choch_bull or ev_bos_bull or ev_sweep_dn?bullCol:ev_choch_bear or ev_bos_bear or ev_sweep_up?bearCol:htf_choch_b?bullCol:htf_choch_r?bearCol:color.gray
    table.cell(t, 0, 5, "Evento", text_color=color.gray, text_size=size.small)
    table.cell(t, 1, 5, lev, text_color=lec, text_size=size.small)
    table.cell(t, 2, 5, "", text_size=size.tiny)

    string zone_str = smc_main>80?"EXTREME OB":smc_main>50?"OB":smc_main<-80?"EXTREME OS":smc_main<-50?"OS":"NEUTRAL"
    color  zone_col = smc_main>50?bearCol:smc_main<-50?bullCol:color.gray
    table.cell(t, 0, 6, "Zona", text_color=color.gray, text_size=size.small)
    table.cell(t, 1, 6, zone_str, text_color=zone_col, text_size=size.small)
    table.cell(t, 2, 6, "", text_size=size.tiny)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ALERTAS                                                        // 6 alertcondition
// Total outputs: 7+5+1+6+4+4+6 = 33 (lÃ­mite 64)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
alertcondition(sig_L3_long,  "ğŸ”¥ L3 LONG",    "SMC L3 LONG  | {{ticker}} @ {{close}} | {{interval}}")
alertcondition(sig_L3_short, "ğŸ”¥ L3 SHORT",   "SMC L3 SHORT | {{ticker}} @ {{close}} | {{interval}}")
alertcondition(sig_L2_long,  "âš¡ L2 LONG",    "SMC L2 LONG  | {{ticker}} @ {{close}} | {{interval}}")
alertcondition(sig_L2_short, "âš¡ L2 SHORT",   "SMC L2 SHORT | {{ticker}} @ {{close}} | {{interval}}")

alertcondition(sig_L1_long,  "L1 LONG",    "SMC L1 LONG  | {{ticker}} @ {{close}} | {{interval}}")
alertcondition(sig_L1_short, "L1 SHORT",   "SMC L1 SHORT | {{ticker}} @ {{close}} | {{interval}}")
alertcondition(htf_choch_b,  "HTF CHoCH â–²",   "SMC CHoCH BULL HTF | {{ticker}}")
alertcondition(htf_choch_r,  "HTF CHoCH â–¼",   "SMC CHoCH BEAR HTF | {{ticker}}")
