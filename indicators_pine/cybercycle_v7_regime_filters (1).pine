// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0
// © Ehlers Cyber Cycle SIGNALS v7.0 — Regime-Aware Edition
//
// Changes from v6.2:
//   ✅ [P1] CYCLE AMPLITUDE FILTER — suppresses signals when cycle amplitude is too small
//   ✅ [P2] SQUEEZE FILTER (BB inside KC) — detects volatility compression = ranging
//   ✅ [P3] ADX FILTER — classic trend strength gate
//   ✅ [P4] CYCLE STRENGTH FILTER — autocorrelation peak quality from periodogram
//   ✅ [P5] SNR FILTER — signal-to-noise ratio of the dominant cycle
//   ✅ All 5 filters are independently toggleable (on/off per filter)
//   ✅ Regime status in info table + background coloring
//   ✅ Confidence system now includes regime bonus/penalty
//
// Carried from v6.2:
//   ✅ Per-Coin Alpha Method + Per-Coin iTrend + Price Labels
//
// References:
// - John Ehlers, "Cybernetic Analysis for Stocks and Futures" (2004)
// - John Ehlers, "Cycle Analytics for Traders" (2013)
// - John Ehlers, "MESA and Trading Market Cycles" (2nd ed, 2001)
// - John Carter, "Mastering the Trade" (TTM Squeeze concept)

//@version=6
indicator("Ehlers CyberCycle v7.0 Regime Filter", shorttitle="CC v7.0", overlay=true, max_labels_count=500)


// ╔══════════════════════════════════════════════════════════════════╗
// ║                     GLOBAL SETTINGS                             ║
// ╚══════════════════════════════════════════════════════════════════╝

grp_global = "══════ GLOBAL SETTINGS ══════"
srcCyber       = input.source(hl2, "Source", group=grp_global)
signalMode     = input.string("Per Coin", "Confidence Mode",
     options=["Per Coin", "Conservative", "Standard", "Aggressive"], group=grp_global)


// ╔══════════════════════════════════════════════════════════════════╗
// ║                     ALPHA METHOD PARAMETERS                     ║
// ╚══════════════════════════════════════════════════════════════════╝

// ─── HOMODYNE ───
grp_hd = "── Homodyne Params ──"
hdMinPeriod    = input.float(3.0, "Min Period", minval=2, maxval=10, step=1, group=grp_hd)
hdMaxPeriod    = input.float(40.0, "Max Period", minval=15, maxval=80, step=5, group=grp_hd)

// ─── MAMA ───
grp_mama = "── MAMA Params ──"
mamaFastLimit  = input.float(0.5, "Fast Limit (alpha max)", minval=0.2, maxval=0.8, step=0.05, group=grp_mama,
     tooltip="Maximum alpha when phase changes fast.\nHigher = more reactive to moves.\nCrypto: 0.4-0.6")
mamaSlowLimit  = input.float(0.05, "Slow Limit (alpha min)", minval=0.01, maxval=0.2, step=0.01, group=grp_mama,
     tooltip="Minimum alpha during quiet periods.\nLower = smoother during consolidation.\nCrypto: 0.03-0.10")

// ─── AUTOCORRELATION ───
grp_ac = "── Autocorrelation Params ──"
acMinPeriod    = input.int(6, "Min Period", minval=3, maxval=15, group=grp_ac)
acMaxPeriod    = input.int(48, "Max Period", minval=20, maxval=80, group=grp_ac)
acAvgLength    = input.int(3, "Avg Length", minval=1, maxval=5, group=grp_ac,
     tooltip="Averaging cycles for autocorrelation.\nHigher = smoother but slower.")

// ─── KALMAN ───
grp_kal = "── Kalman Params ──"
kalProcessNoise = input.float(0.01, "Process Noise (Q)", minval=0.001, maxval=0.2, step=0.005, group=grp_kal,
     tooltip="State uncertainty. Higher = more responsive.\nCrypto: 0.005-0.05")
kalMeasNoise    = input.float(0.5, "Measurement Noise (R)", minval=0.05, maxval=3.0, step=0.1, group=grp_kal,
     tooltip="Observation noise. Higher = more smoothing.")
kalAlphaFast    = input.float(0.5, "Alpha Fast", minval=0.2, maxval=0.8, step=0.05, group=grp_kal)
kalAlphaSlow    = input.float(0.05, "Alpha Slow", minval=0.01, maxval=0.2, step=0.01, group=grp_kal)
kalSensitivity  = input.float(2.0, "Sensitivity", minval=0.5, maxval=5.0, step=0.5, group=grp_kal,
     tooltip="How aggressively alpha responds to innovation.\nHigher = more reactive to price surprises.")


// ╔══════════════════════════════════════════════════════════════════╗
// ║                     PER-COIN CONFIGURATION                      ║
// ║  Now includes: Alpha Method + iTrend Alpha + Manual Alpha       ║
// ╚══════════════════════════════════════════════════════════════════╝

// ─── BTC ───
grp_BTC = "──── BTC ────"
cfg_BTC_alphaM    = input.string("MAMA", "Alpha Method", options=["Homodyne","MAMA","Autocorrelation","Kalman","Manual"], group=grp_BTC,
     tooltip="Alpha estimation method for BTC.\nMAMA recommended for BTC due to its strong cyclical behavior.")
cfg_BTC_manAlpha  = input.float(0.35, "Manual Alpha (if Manual)", minval=0.05, maxval=0.80, step=0.01, group=grp_BTC)
cfg_BTC_iTrendA   = input.float(0.07, "iTrend Alpha", minval=0.01, maxval=0.3, step=0.01, group=grp_BTC,
     tooltip="iTrend smoothing for BTC.\nLower = smoother trend line.\nBTC: 0.05-0.10 recommended.")
cfg_BTC_trigEma   = input.int(14,    "Trigger EMA",       minval=3,   maxval=30,                 group=grp_BTC)
cfg_BTC_minBars   = input.int(24,    "Min Bars Between",  minval=5,   maxval=50,                 group=grp_BTC)
cfg_BTC_conf      = input.float(80,  "Confidence Min %",  minval=30,  maxval=95,  step=5,        group=grp_BTC)
cfg_BTC_volMult   = input.float(2.0, "Volume Multiplier", minval=0.5, maxval=5.0, step=0.1,     group=grp_BTC)
cfg_BTC_ob        = input.float(1.5, "OB Level",          minval=0.3, maxval=3.0, step=0.1,     group=grp_BTC)
cfg_BTC_os        = input.float(-1.5,"OS Level",          minval=-3.0,maxval=-0.3,step=0.1,     group=grp_BTC)
cfg_BTC_aFloor    = input.float(0.0, "Alpha Floor (0=off)",minval=0.0,maxval=0.50,step=0.01,    group=grp_BTC)
cfg_BTC_htf       = input.bool(true, "Use HTF Filter",    group=grp_BTC)
cfg_BTC_trend     = input.bool(true, "Use Trend Filter",  group=grp_BTC)
cfg_BTC_vol       = input.bool(true, "Use Volume Filter", group=grp_BTC)

// ─── ETH ───
grp_ETH = "──── ETH ────"
cfg_ETH_alphaM    = input.string("MAMA", "Alpha Method", options=["Homodyne","MAMA","Autocorrelation","Kalman","Manual"], group=grp_ETH,
     tooltip="Alpha estimation method for ETH.\nMAMA or Kalman recommended.")
cfg_ETH_manAlpha  = input.float(0.35, "Manual Alpha (if Manual)", minval=0.05, maxval=0.80, step=0.01, group=grp_ETH)
cfg_ETH_iTrendA   = input.float(0.07, "iTrend Alpha", minval=0.01, maxval=0.3, step=0.01, group=grp_ETH,
     tooltip="iTrend smoothing for ETH.\nETH: 0.05-0.09 recommended.")
cfg_ETH_trigEma   = input.int(12,    "Trigger EMA",       minval=3,   maxval=30,                 group=grp_ETH)
cfg_ETH_minBars   = input.int(20,    "Min Bars Between",  minval=5,   maxval=50,                 group=grp_ETH)
cfg_ETH_conf      = input.float(80,  "Confidence Min %",  minval=30,  maxval=95,  step=5,        group=grp_ETH)
cfg_ETH_volMult   = input.float(2.0, "Volume Multiplier", minval=0.5, maxval=5.0, step=0.1,     group=grp_ETH)
cfg_ETH_ob        = input.float(1.5, "OB Level",          minval=0.3, maxval=3.0, step=0.1,     group=grp_ETH)
cfg_ETH_os        = input.float(-1.5,"OS Level",          minval=-3.0,maxval=-0.3,step=0.1,     group=grp_ETH)
cfg_ETH_aFloor    = input.float(0.0, "Alpha Floor (0=off)",minval=0.0,maxval=0.50,step=0.01,    group=grp_ETH)
cfg_ETH_htf       = input.bool(true, "Use HTF Filter",    group=grp_ETH)
cfg_ETH_trend     = input.bool(true, "Use Trend Filter",  group=grp_ETH)
cfg_ETH_vol       = input.bool(true, "Use Volume Filter", group=grp_ETH)

// ─── SOL ───
grp_SOL = "──── SOL ────"
cfg_SOL_alphaM    = input.string("MAMA", "Alpha Method", options=["Homodyne","MAMA","Autocorrelation","Kalman","Manual"], group=grp_SOL,
     tooltip="Alpha estimation method for SOL.\nSOL tiene ciclos más rápidos, MAMA o Autocorrelation van bien.")
cfg_SOL_manAlpha  = input.float(0.40, "Manual Alpha (if Manual)", minval=0.05, maxval=0.80, step=0.01, group=grp_SOL)
cfg_SOL_iTrendA   = input.float(0.09, "iTrend Alpha", minval=0.01, maxval=0.3, step=0.01, group=grp_SOL,
     tooltip="iTrend smoothing for SOL.\nSOL is more volatile, slightly higher alpha works.\nSOL: 0.07-0.12 recommended.")
cfg_SOL_trigEma   = input.int(10,    "Trigger EMA",       minval=3,   maxval=30,                 group=grp_SOL)
cfg_SOL_minBars   = input.int(18,    "Min Bars Between",  minval=5,   maxval=50,                 group=grp_SOL)
cfg_SOL_conf      = input.float(75,  "Confidence Min %",  minval=30,  maxval=95,  step=5,        group=grp_SOL)
cfg_SOL_volMult   = input.float(1.2, "Volume Multiplier", minval=0.5, maxval=5.0, step=0.1,     group=grp_SOL)
cfg_SOL_ob        = input.float(1.5, "OB Level",          minval=0.3, maxval=3.0, step=0.1,     group=grp_SOL)
cfg_SOL_os        = input.float(-1.5,"OS Level",          minval=-3.0,maxval=-0.3,step=0.1,     group=grp_SOL)
cfg_SOL_aFloor    = input.float(0.0, "Alpha Floor (0=off)",minval=0.0,maxval=0.50,step=0.01,    group=grp_SOL)
cfg_SOL_htf       = input.bool(true, "Use HTF Filter",    group=grp_SOL)
cfg_SOL_trend     = input.bool(true, "Use Trend Filter",  group=grp_SOL)
cfg_SOL_vol       = input.bool(true, "Use Volume Filter", group=grp_SOL)

// ─── DOGE ───
grp_DOGE = "──── DOGE ────"
cfg_DOGE_alphaM   = input.string("Kalman", "Alpha Method", options=["Homodyne","MAMA","Autocorrelation","Kalman","Manual"], group=grp_DOGE,
     tooltip="Alpha estimation method for DOGE.\nKalman handles DOGE's erratic moves well.\nAutocorrelation also solid.")
cfg_DOGE_manAlpha = input.float(0.40, "Manual Alpha (if Manual)", minval=0.05, maxval=0.80, step=0.01, group=grp_DOGE)
cfg_DOGE_iTrendA  = input.float(0.10, "iTrend Alpha", minval=0.01, maxval=0.3, step=0.01, group=grp_DOGE,
     tooltip="iTrend smoothing for DOGE.\nDOGE needs higher alpha to track its spikes.\nDOGE: 0.08-0.15 recommended.")
cfg_DOGE_trigEma  = input.int(9,     "Trigger EMA",       minval=3,   maxval=30,                 group=grp_DOGE)
cfg_DOGE_minBars  = input.int(16,    "Min Bars Between",  minval=5,   maxval=50,                 group=grp_DOGE)
cfg_DOGE_conf     = input.float(75,  "Confidence Min %",  minval=30,  maxval=95,  step=5,        group=grp_DOGE)
cfg_DOGE_volMult  = input.float(1.0, "Volume Multiplier", minval=0.5, maxval=5.0, step=0.1,     group=grp_DOGE)
cfg_DOGE_ob       = input.float(1.5, "OB Level",          minval=0.3, maxval=3.0, step=0.1,     group=grp_DOGE)
cfg_DOGE_os       = input.float(-1.5,"OS Level",          minval=-3.0,maxval=-0.3,step=0.1,     group=grp_DOGE)
cfg_DOGE_aFloor   = input.float(0.0, "Alpha Floor (0=off)",minval=0.0,maxval=0.50,step=0.01,    group=grp_DOGE)
cfg_DOGE_htf      = input.bool(true, "Use HTF Filter",    group=grp_DOGE)
cfg_DOGE_trend    = input.bool(true, "Use Trend Filter",  group=grp_DOGE)
cfg_DOGE_vol      = input.bool(true, "Use Volume Filter", group=grp_DOGE)
// ─── BCH───
grp_BCH = "──── BCH ────"
cfg_BCH_alphaM   = input.string("Kalman", "Alpha Method", options=["Homodyne","MAMA","Autocorrelation","Kalman","Manual"], group=grp_BCH,
     tooltip="Alpha estimation method for BCH.\nKalman handles BCH's erratic moves well.\nAutocorrelation also solid.")
cfg_BCH_manAlpha = input.float(0.40, "Manual Alpha (if Manual)", minval=0.05, maxval=0.80, step=0.01, group=grp_BCH)
cfg_BCH_iTrendA  = input.float(0.10, "iTrend Alpha", minval=0.01, maxval=0.3, step=0.01, group=grp_BCH,
     tooltip="iTrend smoothing for BCH.\nBCH needs higher alpha to track its spikes.\nBCH: 0.08-0.15 recommended.")
cfg_BCH_trigEma  = input.int(9,     "Trigger EMA",       minval=3,   maxval=30,                 group=grp_BCH)
cfg_BCH_minBars  = input.int(16,    "Min Bars Between",  minval=5,   maxval=50,                 group=grp_BCH)
cfg_BCH_conf     = input.float(75,  "Confidence Min %",  minval=30,  maxval=95,  step=5,        group=grp_BCH)
cfg_BCH_volMult  = input.float(1.0, "Volume Multiplier", minval=0.5, maxval=5.0, step=0.1,     group=grp_BCH)
cfg_BCH_ob       = input.float(1.5, "OB Level",          minval=0.3, maxval=3.0, step=0.1,     group=grp_BCH)
cfg_BCH_os       = input.float(-1.5,"OS Level",          minval=-3.0,maxval=-0.3,step=0.1,     group=grp_BCH)
cfg_BCH_aFloor   = input.float(0.0, "Alpha Floor (0=off)",minval=0.0,maxval=0.50,step=0.01,    group=grp_BCH)
cfg_BCH_htf      = input.bool(true, "Use HTF Filter",    group=grp_BCH)
cfg_BCH_trend    = input.bool(true, "Use Trend Filter",  group=grp_BCH)
cfg_BCH_vol      = input.bool(true, "Use Volume Filter", group=grp_BCH)
// ─── UNI ───
grp_UNI = "──── UNI ────"
cfg_UNI_alphaM   = input.string("Kalman", "Alpha Method", options=["Homodyne","MAMA","Autocorrelation","Kalman","Manual"], group=grp_UNI,
     tooltip="Alpha estimation method for UNI.\nKalman handles UNI's erratic moves well.\nAutocorrelation also solid.")
cfg_UNI_manAlpha = input.float(0.40, "Manual Alpha (if Manual)", minval=0.05, maxval=0.80, step=0.01, group=grp_UNI)
cfg_UNI_iTrendA  = input.float(0.10, "iTrend Alpha", minval=0.01, maxval=0.3, step=0.01, group=grp_UNI,
     tooltip="iTrend smoothing for UNI.\nUNI needs higher alpha to track its spikes.\nUNI: 0.08-0.15 recommended.")
cfg_UNI_trigEma  = input.int(9,     "Trigger EMA",       minval=3,   maxval=30,                 group=grp_UNI)
cfg_UNI_minBars  = input.int(16,    "Min Bars Between",  minval=5,   maxval=50,                 group=grp_UNI)
cfg_UNI_conf     = input.float(75,  "Confidence Min %",  minval=30,  maxval=95,  step=5,        group=grp_UNI)
cfg_UNI_volMult  = input.float(1.0, "Volume Multiplier", minval=0.5, maxval=5.0, step=0.1,     group=grp_UNI)
cfg_UNI_ob       = input.float(1.5, "OB Level",          minval=0.3, maxval=3.0, step=0.1,     group=grp_UNI)
cfg_UNI_os       = input.float(-1.5,"OS Level",          minval=-3.0,maxval=-0.3,step=0.1,     group=grp_UNI)
cfg_UNI_aFloor   = input.float(0.0, "Alpha Floor (0=off)",minval=0.0,maxval=0.50,step=0.01,    group=grp_UNI)
cfg_UNI_htf      = input.bool(true, "Use HTF Filter",    group=grp_UNI)
cfg_UNI_trend    = input.bool(true, "Use Trend Filter",  group=grp_UNI)
cfg_UNI_vol      = input.bool(true, "Use Volume Filter", group=grp_UNI)
// ─── PEPE ───
grp_PEPE = "──── PEPE ────"
cfg_PEPE_alphaM   = input.string("Kalman", "Alpha Method", options=["Homodyne","MAMA","Autocorrelation","Kalman","Manual"], group=grp_PEPE,
     tooltip="Alpha estimation method for PEPE.\nKalman handles PEPE's erratic moves well.\nAutocorrelation also solid.")
cfg_PEPE_manAlpha = input.float(0.40, "Manual Alpha (if Manual)", minval=0.05, maxval=0.80, step=0.01, group=grp_PEPE)
cfg_PEPE_iTrendA  = input.float(0.10, "iTrend Alpha", minval=0.01, maxval=0.3, step=0.01, group=grp_PEPE,
     tooltip="iTrend smoothing for PEPE.\nPEPE needs higher alpha to track its spikes.\nPEPE: 0.08-0.15 recommended.")
cfg_PEPE_trigEma  = input.int(9,     "Trigger EMA",       minval=3,   maxval=30,                 group=grp_PEPE)
cfg_PEPE_minBars  = input.int(16,    "Min Bars Between",  minval=5,   maxval=50,                 group=grp_PEPE)
cfg_PEPE_conf     = input.float(75,  "Confidence Min %",  minval=30,  maxval=95,  step=5,        group=grp_PEPE)
cfg_PEPE_volMult  = input.float(1.0, "Volume Multiplier", minval=0.5, maxval=5.0, step=0.1,     group=grp_PEPE)
cfg_PEPE_ob       = input.float(1.5, "OB Level",          minval=0.3, maxval=3.0, step=0.1,     group=grp_PEPE)
cfg_PEPE_os       = input.float(-1.5,"OS Level",          minval=-3.0,maxval=-0.3,step=0.1,     group=grp_PEPE)
cfg_PEPE_aFloor   = input.float(0.0, "Alpha Floor (0=off)",minval=0.0,maxval=0.50,step=0.01,    group=grp_PEPE)
cfg_PEPE_htf      = input.bool(true, "Use HTF Filter",    group=grp_PEPE)
cfg_PEPE_trend    = input.bool(true, "Use Trend Filter",  group=grp_PEPE)
cfg_PEPE_vol      = input.bool(true, "Use Volume Filter", group=grp_PEPE)
// ─── ONDO ───
grp_ONDO = "──── ONDO ────"
cfg_ONDO_alphaM   = input.string("Kalman", "Alpha Method", options=["Homodyne","MAMA","Autocorrelation","Kalman","Manual"], group=grp_ONDO,
     tooltip="Alpha estimation method for ONDO.\nKalman handles ONDO's erratic moves well.\nAutocorrelation also solid.")
cfg_ONDO_manAlpha = input.float(0.40, "Manual Alpha (if Manual)", minval=0.05, maxval=0.80, step=0.01, group=grp_ONDO)
cfg_ONDO_iTrendA  = input.float(0.10, "iTrend Alpha", minval=0.01, maxval=0.3, step=0.01, group=grp_ONDO,
     tooltip="iTrend smoothing for ONDO.\nONDO needs higher alpha to track its spikes.\nONDO: 0.08-0.15 recommended.")
cfg_ONDO_trigEma  = input.int(9,     "Trigger EMA",       minval=3,   maxval=30,                 group=grp_ONDO)
cfg_ONDO_minBars  = input.int(16,    "Min Bars Between",  minval=5,   maxval=50,                 group=grp_ONDO)
cfg_ONDO_conf     = input.float(75,  "Confidence Min %",  minval=30,  maxval=95,  step=5,        group=grp_ONDO)
cfg_ONDO_volMult  = input.float(1.0, "Volume Multiplier", minval=0.5, maxval=5.0, step=0.1,     group=grp_ONDO)
cfg_ONDO_ob       = input.float(1.5, "OB Level",          minval=0.3, maxval=3.0, step=0.1,     group=grp_ONDO)
cfg_ONDO_os       = input.float(-1.5,"OS Level",          minval=-3.0,maxval=-0.3,step=0.1,     group=grp_ONDO)
cfg_ONDO_aFloor   = input.float(0.0, "Alpha Floor (0=off)",minval=0.0,maxval=0.50,step=0.01,    group=grp_ONDO)
cfg_ONDO_htf      = input.bool(true, "Use HTF Filter",    group=grp_ONDO)
cfg_ONDO_trend    = input.bool(true, "Use Trend Filter",  group=grp_ONDO)
cfg_ONDO_vol      = input.bool(true, "Use Volume Filter", group=grp_ONDO)
// ─── DEFAULT ───
grp_DEF = "──── DEFAULT ────"
cfg_DEF_alphaM    = input.string("MAMA", "Alpha Method", options=["Homodyne","MAMA","Autocorrelation","Kalman","Manual"], group=grp_DEF,
     tooltip="Alpha estimation method for unrecognized coins.\nMAMA is a safe default.")
cfg_DEF_manAlpha  = input.float(0.35, "Manual Alpha (if Manual)", minval=0.05, maxval=0.80, step=0.01, group=grp_DEF)
cfg_DEF_iTrendA   = input.float(0.07, "iTrend Alpha", minval=0.01, maxval=0.3, step=0.01, group=grp_DEF,
     tooltip="iTrend smoothing for default coins.")
cfg_DEF_trigEma   = input.int(10,    "Trigger EMA",       minval=3,   maxval=30,                 group=grp_DEF)
cfg_DEF_minBars   = input.int(18,    "Min Bars Between",  minval=5,   maxval=50,                 group=grp_DEF)
cfg_DEF_conf      = input.float(75,  "Confidence Min %",  minval=30,  maxval=95,  step=5,        group=grp_DEF)
cfg_DEF_volMult   = input.float(1.5, "Volume Multiplier", minval=0.5, maxval=5.0, step=0.1,     group=grp_DEF)
cfg_DEF_ob        = input.float(1.5, "OB Level",          minval=0.3, maxval=3.0, step=0.1,     group=grp_DEF)
cfg_DEF_os        = input.float(-1.5,"OS Level",          minval=-3.0,maxval=-0.3,step=0.1,     group=grp_DEF)
cfg_DEF_aFloor    = input.float(0.0, "Alpha Floor (0=off)",minval=0.0,maxval=0.50,step=0.01,    group=grp_DEF)
cfg_DEF_htf       = input.bool(true, "Use HTF Filter",    group=grp_DEF)
cfg_DEF_trend     = input.bool(true, "Use Trend Filter",  group=grp_DEF)
cfg_DEF_vol       = input.bool(true, "Use Volume Filter", group=grp_DEF)


// ╔══════════════════════════════════════════════════════════════════╗
// ║                     REGIME FILTERS                               ║
// ║  5 independent filters to suppress signals during ranging        ║
// ║  Each is toggleable — combine as needed                          ║
// ╚══════════════════════════════════════════════════════════════════╝

grp_regime = "══════ REGIME FILTERS ══════"

// ─── P1: CYCLE AMPLITUDE ───
bool   useAmpFilter  = input.bool (true, "① Cycle Amplitude Filter", group=grp_regime,
     tooltip="Suppresses signals when the CyberCycle amplitude is too small relative to its history.\nThis is the most direct ranging detector — if the cycle is tiny, there's nothing to trade.")
int    ampLookback   = input.int  (50,   "  Amp Lookback",   minval=20, maxval=200, group=grp_regime,
     tooltip="Bars to average for historical amplitude baseline.\n50 = ~2 days at 1H.")
float  ampThreshold  = input.float(0.40, "  Amp Threshold",  minval=0.10, maxval=0.90, step=0.05, group=grp_regime,
     tooltip="Min ratio of current amplitude vs average.\n0.40 = cycle must be ≥40% of its average size.\nLower = more signals in ranging (riskier).\nHigher = only strong cycles trade.")

// ─── P2: SQUEEZE (BB inside KC) ───
bool   useSqueeze    = input.bool (true, "② Squeeze Filter (BB/KC)", group=grp_regime,
     tooltip="Detects Bollinger Bands inside Keltner Channels = volatility compression = ranging.\nInspired by John Carter's TTM Squeeze.\nNo signals during squeeze.")
int    sqzLen        = input.int  (20,   "  Squeeze Length",  minval=10, maxval=50,  group=grp_regime)
float  sqzBBMult     = input.float(2.0,  "  BB Multiplier",  minval=1.0, maxval=3.0, step=0.1, group=grp_regime)
float  sqzKCMult     = input.float(1.5,  "  KC Multiplier",  minval=0.5, maxval=3.0, step=0.1, group=grp_regime,
     tooltip="BB Mult=2.0, KC Mult=1.5 is the classic Carter setup.\nLower KC Mult = detects tighter squeezes only.\nHigher KC Mult = more aggressive filtering.")

// ─── P3: ADX ───
bool   useADX        = input.bool (true, "③ ADX Trend Strength", group=grp_regime,
     tooltip="Classic ADX filter. ADX < threshold = no directional movement = ranging.\nSimple and reliable complementary filter.")
int    adxLen        = input.int  (14,   "  ADX Length",      minval=7,  maxval=30,  group=grp_regime)
float  adxMinVal     = input.float(20.0, "  ADX Minimum",    minval=10.0,maxval=40.0,step=1.0, group=grp_regime,
     tooltip="ADX below this = ranging.\n20 is the classic Wilder threshold.\nCrypto: 18-25 works well.\nHigher = more restrictive.")

// ─── P4: CYCLE STRENGTH (Autocorrelation Peak) ───
bool   useCycleStr   = input.bool (false,"④ Cycle Strength (Autocorr)", group=grp_regime,
     tooltip="Uses the peak correlation from the Autocorrelation Periodogram.\nIf no dominant cycle is clear (low correlation), signals are suppressed.\nThis is the most 'Ehlers-native' filter but requires Autocorrelation method to run.\nWorks with any alpha method since all methods run every bar.")
float  minCycleCorr  = input.float(0.40, "  Min Correlation", minval=0.15, maxval=0.85, step=0.05, group=grp_regime,
     tooltip="Minimum autocorrelation peak strength.\n0.40 = moderate cycle quality.\n0.60 = strong cycle required.\nCrypto is noisy — 0.30-0.50 typical range.")

// ─── P5: SNR (Signal-to-Noise Ratio) ───
bool   useSNR        = input.bool (false,"⑤ SNR Filter (dB)", group=grp_regime,
     tooltip="Measures the Signal-to-Noise ratio of the CyberCycle.\nIf the cycle power is weak compared to price noise, it's likely ranging.\nMore theoretical — use as complementary filter.")
float  snrMinDB      = input.float(3.0,  "  Min SNR (dB)",   minval=0.5, maxval=10.0, step=0.5, group=grp_regime,
     tooltip="Minimum SNR in decibels.\n3 dB = signal is 2× stronger than noise.\n6 dB = 4× stronger.\nCrypto: 2-4 dB is realistic.")
int    snrSmoothLen  = input.int  (20,   "  SNR Smooth Len", minval=5, maxval=50, group=grp_regime,
     tooltip="Smoothing length for SNR calculation.\nHigher = more stable but slower to react.")


// ╔══════════════════════════════════════════════════════════════════╗
// ║                     COIN DETECTION                              ║
// ╚══════════════════════════════════════════════════════════════════╝

string baseCur = syminfo.basecurrency
string detectedCoin = switch baseCur
    "BTC"  => "BTC"
    "ETH"  => "ETH"
    "SOL"  => "SOL"
    "DOGE" => "DOGE"
    "BCH" => "BCH"
    "UNI" => "UNI"
    "PEPE" => "PEPE"
    "ONDO" => "ONDO"
    => "DEF"

// ─── Per-coin Alpha Method ───
string eAlphaMethod = switch detectedCoin
    "BTC"  => cfg_BTC_alphaM
    "ETH"  => cfg_ETH_alphaM
    "SOL"  => cfg_SOL_alphaM
    "DOGE" => cfg_DOGE_alphaM
    "BCH" => cfg_BCH_alphaM
    "UNI" => cfg_UNI_alphaM
    "PEPE" => cfg_PEPE_alphaM
    "ONDO" => cfg_ONDO_alphaM
    => cfg_DEF_alphaM

// ─── Per-coin Manual Alpha ───
float eManualAlpha = switch detectedCoin
    "BTC"  => cfg_BTC_manAlpha
    "ETH"  => cfg_ETH_manAlpha
    "SOL"  => cfg_SOL_manAlpha
    "DOGE" => cfg_DOGE_manAlpha
    "BCH" => cfg_BCH_manAlpha
    "UNI" => cfg_UNI_manAlpha
    "PEPE" => cfg_PEPE_manAlpha
    "ONDO" => cfg_ONDO_manAlpha
    => cfg_DEF_manAlpha

// ─── Per-coin iTrend Alpha ───
float eITrendAlpha = switch detectedCoin
    "BTC"  => cfg_BTC_iTrendA
    "ETH"  => cfg_ETH_iTrendA
    "SOL"  => cfg_SOL_iTrendA
    "DOGE" => cfg_DOGE_iTrendA
     "BCH" => cfg_BCH_iTrendA
    "UNI" => cfg_UNI_iTrendA
    "PEPE" => cfg_PEPE_iTrendA
    "ONDO" => cfg_ONDO_iTrendA

    => cfg_DEF_iTrendA

int    eTrigEma   = switch detectedCoin
    "BTC" => cfg_BTC_trigEma,  
    "ETH" => cfg_ETH_trigEma,
    "SOL" => cfg_SOL_trigEma,  
    "DOGE" => cfg_DOGE_trigEma,
     "BCH" => cfg_BCH_trigEma
    "UNI" => cfg_UNI_trigEma
    "PEPE" => cfg_PEPE_trigEma
    "ONDO" => cfg_ONDO_trigEma
    => cfg_DEF_trigEma
int    eMinBars   = switch detectedCoin
    "BTC" => cfg_BTC_minBars,  
    "ETH" => cfg_ETH_minBars,
    "SOL" => cfg_SOL_minBars,  
    "DOGE" => cfg_DOGE_minBars,
     "BCH" => cfg_BCH_minBars
    "UNI" => cfg_UNI_minBars
    "PEPE" => cfg_PEPE_minBars
    "ONDO" => cfg_ONDO_minBars
    => cfg_DEF_minBars
float  eCoinConf  = switch detectedCoin
    "BTC" => cfg_BTC_conf,     
    "ETH" => cfg_ETH_conf,
    "SOL" => cfg_SOL_conf,     
    "DOGE" => cfg_DOGE_conf,
     "BCH" => cfg_BCH_conf
    "UNI" => cfg_UNI_conf
    "PEPE" => cfg_PEPE_conf
    "ONDO" => cfg_ONDO_conf
    => cfg_DEF_conf
float  eVolMult   = switch detectedCoin
    "BTC" => cfg_BTC_volMult,  
    "ETH" => cfg_ETH_volMult,
    "SOL" => cfg_SOL_volMult,  
    "DOGE" => cfg_DOGE_volMult,
     "BCH" => cfg_BCH_volMult
    "UNI" => cfg_UNI_volMult
    "PEPE" => cfg_PEPE_volMult
    "ONDO" => cfg_ONDO_volMult
    => cfg_DEF_volMult
float  eOB        = switch detectedCoin
    "BTC" => cfg_BTC_ob,       
    "ETH" => cfg_ETH_ob,
    "SOL" => cfg_SOL_ob,       
    "DOGE" => cfg_DOGE_ob,
     "BCH" => cfg_BCH_ob
    "UNI" => cfg_UNI_ob
    "PEPE" => cfg_PEPE_ob
    "ONDO" => cfg_ONDO_ob
    => cfg_DEF_ob
float  eOS        = switch detectedCoin
    "BTC" => cfg_BTC_os,       
    "ETH" => cfg_ETH_os,
    "SOL" => cfg_SOL_os,       
    "DOGE" => cfg_DOGE_os,
    "BCH" => cfg_BCH_os
    "UNI" => cfg_UNI_os
    "PEPE" => cfg_PEPE_os
    "ONDO" => cfg_ONDO_os
    => cfg_DEF_os
float  eAFloor    = switch detectedCoin
    "BTC" => cfg_BTC_aFloor,   
    "ETH" => cfg_ETH_aFloor,
    "SOL" => cfg_SOL_aFloor,   
    "DOGE" => cfg_DOGE_aFloor,
    "BCH" => cfg_BCH_aFloor
    "UNI" => cfg_UNI_aFloor
    "PEPE" => cfg_PEPE_aFloor
    "ONDO" => cfg_ONDO_aFloor
    => cfg_DEF_aFloor
bool   eUseHTF    = switch detectedCoin
    "BTC" => cfg_BTC_htf,      
    "ETH" => cfg_ETH_htf,
    "SOL" => cfg_SOL_htf,      
    "DOGE" => cfg_DOGE_htf,
    "BCH" => cfg_BCH_htf
    "UNI" => cfg_UNI_htf
    "PEPE" => cfg_PEPE_htf
    "ONDO" => cfg_ONDO_htf
    => cfg_DEF_htf
bool   eUseTrend  = switch detectedCoin
    "BTC" => cfg_BTC_trend,    
    "ETH" => cfg_ETH_trend,
    "SOL" => cfg_SOL_trend,    
    "DOGE" => cfg_DOGE_trend,
    "BCH" => cfg_BCH_trend
    "UNI" => cfg_UNI_trend
    "PEPE" => cfg_PEPE_trend
    "ONDO" => cfg_ONDO_trend
    => cfg_DEF_trend
bool   eUseVol    = switch detectedCoin
    "BTC" => cfg_BTC_vol,      
    "ETH" => cfg_ETH_vol,
    "SOL" => cfg_SOL_vol,      
    "DOGE" => cfg_DOGE_vol,
    "BCH" => cfg_BCH_vol
    "UNI" => cfg_UNI_vol
    "PEPE" => cfg_PEPE_vol
    "ONDO" => cfg_ONDO_vol
    => cfg_DEF_vol

float minConf = switch signalMode
    "Conservative" => 80.0
    "Standard"     => 50.0
    "Aggressive"   => 30.0
    => eCoinConf


// ╔══════════════════════════════════════════════════════════════════╗
// ║              ALPHA METHOD 1: HOMODYNE DISCRIMINATOR             ║
// ╚══════════════════════════════════════════════════════════════════╝

f_homodyne() =>
    var float _hd_smooth = 0.0
    _hd_smooth := (4.0 * srcCyber + 3.0 * nz(srcCyber[1]) + 2.0 * nz(srcCyber[2]) + nz(srcCyber[3])) / 10.0

    var float _hd_period = 15.0
    float _hd_adj = 0.075 * nz(_hd_period[1], 15.0) + 0.54

    var float _hd_det = 0.0
    _hd_det := (0.0962 * _hd_smooth + 0.5769 * nz(_hd_smooth[2]) - 0.5769 * nz(_hd_smooth[4]) - 0.0962 * nz(_hd_smooth[6])) * _hd_adj

    var float _hd_Q1 = 0.0
    _hd_Q1 := (0.0962 * _hd_det + 0.5769 * nz(_hd_det[2]) - 0.5769 * nz(_hd_det[4]) - 0.0962 * nz(_hd_det[6])) * _hd_adj
    float _hd_I1 = nz(_hd_det[3])

    var float _hd_jI = 0.0
    var float _hd_jQ = 0.0
    _hd_jI := (0.0962 * _hd_I1 + 0.5769 * nz(_hd_I1[2]) - 0.5769 * nz(_hd_I1[4]) - 0.0962 * nz(_hd_I1[6])) * _hd_adj
    _hd_jQ := (0.0962 * _hd_Q1 + 0.5769 * nz(_hd_Q1[2]) - 0.5769 * nz(_hd_Q1[4]) - 0.0962 * nz(_hd_Q1[6])) * _hd_adj

    var float _hd_I2 = 0.0
    var float _hd_Q2 = 0.0
    _hd_I2 := 0.2 * (_hd_I1 - _hd_jQ) + 0.8 * nz(_hd_I2[1])
    _hd_Q2 := 0.2 * (_hd_Q1 + _hd_jI) + 0.8 * nz(_hd_Q2[1])

    var float _hd_Re = 0.0
    var float _hd_Im = 0.0
    _hd_Re := 0.2 * (_hd_I2 * nz(_hd_I2[1]) + _hd_Q2 * nz(_hd_Q2[1])) + 0.8 * nz(_hd_Re[1])
    _hd_Im := 0.2 * (_hd_I2 * nz(_hd_Q2[1]) - _hd_Q2 * nz(_hd_I2[1])) + 0.8 * nz(_hd_Im[1])

    float _hd_phaseAdv = (math.abs(_hd_Im) > 1e-10 and math.abs(_hd_Re) > 1e-10) ? math.atan(_hd_Im / _hd_Re) : 0.0
    float _hd_rawPer = _hd_phaseAdv > 0.001 ? 2.0 * math.pi / _hd_phaseAdv : nz(_hd_period[1], 15.0)
    _hd_rawPer := math.max(_hd_rawPer, 0.67 * nz(_hd_period[1], 15.0))
    _hd_rawPer := math.min(_hd_rawPer, 1.5 * nz(_hd_period[1], 15.0))
    _hd_rawPer := math.max(hdMinPeriod, math.min(hdMaxPeriod, _hd_rawPer))
    _hd_period := 0.2 * _hd_rawPer + 0.8 * nz(_hd_period[1], 15.0)

    var float _hd_smoothPeriod = 15.0
    _hd_smoothPeriod := 0.33 * _hd_period + 0.67 * nz(_hd_smoothPeriod[1], 15.0)
    _hd_smoothPeriod := math.max(hdMinPeriod, math.min(hdMaxPeriod, _hd_smoothPeriod))

    float _alpha = 2.0 / (_hd_smoothPeriod + 1.0)
    [_alpha, _hd_smoothPeriod]


// ╔══════════════════════════════════════════════════════════════════╗
// ║              ALPHA METHOD 2: MAMA (Phase Rate)                  ║
// ╚══════════════════════════════════════════════════════════════════╝

f_mama() =>
    float _m_adj = 1.665  // Fixed: 0.075 * 15.0 + 0.54

    var float _m_smooth = 0.0
    _m_smooth := (4.0 * srcCyber + 3.0 * nz(srcCyber[1]) + 2.0 * nz(srcCyber[2]) + nz(srcCyber[3])) / 10.0

    var float _m_det = 0.0
    _m_det := (0.0962 * _m_smooth + 0.5769 * nz(_m_smooth[2]) - 0.5769 * nz(_m_smooth[4]) - 0.0962 * nz(_m_smooth[6])) * _m_adj

    var float _m_Q1 = 0.0
    _m_Q1 := (0.0962 * _m_det + 0.5769 * nz(_m_det[2]) - 0.5769 * nz(_m_det[4]) - 0.0962 * nz(_m_det[6])) * _m_adj
    float _m_I1 = nz(_m_det[3])

    var float _m_jI = 0.0
    var float _m_jQ = 0.0
    _m_jI := (0.0962 * _m_I1 + 0.5769 * nz(_m_I1[2]) - 0.5769 * nz(_m_I1[4]) - 0.0962 * nz(_m_I1[6])) * _m_adj
    _m_jQ := (0.0962 * _m_Q1 + 0.5769 * nz(_m_Q1[2]) - 0.5769 * nz(_m_Q1[4]) - 0.0962 * nz(_m_Q1[6])) * _m_adj

    var float _m_I2 = 0.0
    var float _m_Q2 = 0.0
    _m_I2 := 0.2 * (_m_I1 - _m_jQ) + 0.8 * nz(_m_I2[1])
    _m_Q2 := 0.2 * (_m_Q1 + _m_jI) + 0.8 * nz(_m_Q2[1])

    float _m_sumI = _m_I1 + nz(_m_I1[1])
    float _m_sumQ = _m_Q1 + nz(_m_Q1[1])

    var float _m_phase = 0.0
    float _m_rawPhase = 0.0

    if math.abs(_m_sumI) > 0.001
        _m_rawPhase := math.atan(math.abs(_m_sumQ / _m_sumI)) * (180.0 / math.pi)
    else
        _m_rawPhase := 90.0

    if _m_sumI < 0 and _m_sumQ > 0
        _m_rawPhase := 180.0 - _m_rawPhase
    else if _m_sumI < 0 and _m_sumQ < 0
        _m_rawPhase := 180.0 + _m_rawPhase
    else if _m_sumI > 0 and _m_sumQ < 0
        _m_rawPhase := 360.0 - _m_rawPhase

    _m_phase := _m_rawPhase

    float _m_dp_raw = nz(_m_phase[1], 0.0) - _m_phase

    if _m_dp_raw > 180.0
        _m_dp_raw := _m_dp_raw - 360.0
    if _m_dp_raw < -180.0
        _m_dp_raw := _m_dp_raw + 360.0

    float _m_dp = math.max(1.0, math.min(60.0, _m_dp_raw))

    var float _m_dpSmooth = 5.0
    _m_dpSmooth := 0.33 * _m_dp + 0.67 * nz(_m_dpSmooth[1], 5.0)
    _m_dpSmooth := math.max(1.0, math.min(60.0, _m_dpSmooth))

    float _m_alpha = mamaFastLimit / _m_dpSmooth
    _m_alpha := math.max(mamaSlowLimit, math.min(mamaFastLimit, _m_alpha))

    float _m_periodEst = math.max(2.0, (2.0 / _m_alpha) - 1.0)

    [_m_alpha, _m_periodEst]


// ╔══════════════════════════════════════════════════════════════════╗
// ║         ALPHA METHOD 3: AUTOCORRELATION PERIODOGRAM             ║
// ╚══════════════════════════════════════════════════════════════════╝

f_autocorrelation() =>
    float _ac_a1 = (0.707 * 2.0 * math.pi) / acMaxPeriod
    float _ac_alphaHP = (math.cos(_ac_a1) + math.sin(_ac_a1) - 1.0) / math.cos(_ac_a1)

    var float _ac_hp = 0.0
    _ac_hp := (1.0 - _ac_alphaHP / 2.0) * (1.0 - _ac_alphaHP / 2.0) * (srcCyber - 2.0 * nz(srcCyber[1]) + nz(srcCyber[2])) + 2.0 * (1.0 - _ac_alphaHP) * nz(_ac_hp[1]) - (1.0 - _ac_alphaHP) * (1.0 - _ac_alphaHP) * nz(_ac_hp[2])

    float _ac_a1ss = math.exp(-1.414 * math.pi / acMinPeriod)
    float _ac_b1ss = 2.0 * _ac_a1ss * math.cos(1.414 * math.pi / acMinPeriod)
    float _ac_c2ss = _ac_b1ss
    float _ac_c3ss = -_ac_a1ss * _ac_a1ss
    float _ac_c1ss = 1.0 - _ac_c2ss - _ac_c3ss

    var float _ac_filt = 0.0
    _ac_filt := _ac_c1ss * (_ac_hp + nz(_ac_hp[1])) / 2.0 + _ac_c2ss * nz(_ac_filt[1]) + _ac_c3ss * nz(_ac_filt[2])

    int _ac_step = math.max(1, (acMaxPeriod - acMinPeriod) / 10)

    var float _ac_bestPeriod = 15.0
    float _ac_maxCorr = 0.0
    float _ac_bestP = _ac_bestPeriod

    for p = acMinPeriod to acMaxPeriod by _ac_step
        float _sx = 0.0
        float _sy = 0.0
        float _sxx = 0.0
        float _syy = 0.0
        float _sxy = 0.0
        int _cnt = acAvgLength * p
        for j = 0 to math.min(_cnt - 1, 199)
            float _x = nz(_ac_filt[j])
            float _y = nz(_ac_filt[j + p])
            _sx += _x
            _sy += _y
            _sxx += _x * _x
            _syy += _y * _y
            _sxy += _x * _y
        float _denom = (_cnt * _sxx - _sx * _sx) * (_cnt * _syy - _sy * _sy)
        float _corr = _denom > 0 ? (_cnt * _sxy - _sx * _sy) / math.sqrt(_denom) : 0.0
        if _corr > _ac_maxCorr
            _ac_maxCorr := _corr
            _ac_bestP := float(p)

    _ac_bestPeriod := 0.25 * _ac_bestP + 0.75 * nz(_ac_bestPeriod[1], 15.0)
    _ac_bestPeriod := math.max(acMinPeriod, math.min(acMaxPeriod, _ac_bestPeriod))

    float _ac_alpha = 2.0 / (_ac_bestPeriod + 1.0)
    [_ac_alpha, _ac_bestPeriod, _ac_maxCorr]


// ╔══════════════════════════════════════════════════════════════════╗
// ║          ALPHA METHOD 4: KALMAN INNOVATION-BASED                ║
// ╚══════════════════════════════════════════════════════════════════╝

f_kalman() =>
    var float _k_x = srcCyber
    var float _k_P = 1.0
    var float _k_innovEma = 0.001

    float _k_xPred = _k_x
    float _k_PPred = _k_P + kalProcessNoise

    float _k_innovation = srcCyber - _k_xPred
    float _k_S = _k_PPred + kalMeasNoise
    float _k_K = _k_S > 1e-12 ? _k_PPred / _k_S : 0.5

    _k_x := _k_xPred + _k_K * _k_innovation
    _k_P := (1.0 - _k_K) * _k_PPred

    float _k_absInnov = math.abs(_k_innovation)
    _k_innovEma := 0.05 * _k_absInnov + 0.95 * nz(_k_innovEma[1], 0.001)

    float _k_normInnov = _k_innovEma > 1e-12 ? _k_absInnov / _k_innovEma : 1.0
    float _k_ratio = (_k_normInnov - 1.0) * kalSensitivity
    float _k_sigmoid = 1.0 / (1.0 + math.exp(-_k_ratio))
    float _k_alpha = kalAlphaSlow + (kalAlphaFast - kalAlphaSlow) * _k_sigmoid
    _k_alpha := math.max(kalAlphaSlow, math.min(kalAlphaFast, _k_alpha))

    float _k_period = math.max(2.0, (2.0 / _k_alpha) - 1.0)

    [_k_alpha, _k_period]


// ╔══════════════════════════════════════════════════════════════════╗
// ║                  ALPHA METHOD DISPATCHER                        ║
// ║  Now uses per-coin eAlphaMethod instead of global               ║
// ╚══════════════════════════════════════════════════════════════════╝

// All methods must be called every bar to maintain state continuity.
// Pine Script requires consistent execution — skipping a method on some
// bars would corrupt its internal var state on subsequent bars.
[_a_hd, _p_hd] = f_homodyne()
[_a_ma, _p_ma] = f_mama()
[_a_ac, _p_ac, _ac_peakCorr] = f_autocorrelation()
[_a_kl, _p_kl] = f_kalman()

float adaptiveAlpha = switch eAlphaMethod
    "Homodyne"        => _a_hd
    "MAMA"            => _a_ma
    "Autocorrelation" => _a_ac
    "Kalman"          => _a_kl
    => eManualAlpha  // Manual

float dominantPeriod = switch eAlphaMethod
    "Homodyne"        => _p_hd
    "MAMA"            => _p_ma
    "Autocorrelation" => _p_ac
    "Kalman"          => _p_kl
    => (2.0 / eManualAlpha) - 1.0  // Manual

// Apply per-coin alpha floor
if eAFloor > 0
    adaptiveAlpha := math.max(adaptiveAlpha, eAFloor)


// ╔══════════════════════════════════════════════════════════════════╗
// ║                  ADAPTIVE CYBER CYCLE + SUPPORT                 ║
// ║  iTrend now uses per-coin eITrendAlpha                          ║
// ╚══════════════════════════════════════════════════════════════════╝

f_ema(float src, int len) =>
    float k = 2.0 / (len + 1)
    var float out = 0.0
    out := k * src + (1.0 - k) * nz(out[1])
    out

var float _mainSmooth = 0.0
var float _mainCycle = 0.0
_mainSmooth := (srcCyber + 2.0 * nz(srcCyber[1]) + 2.0 * nz(srcCyber[2]) + nz(srcCyber[3])) / 6.0
if bar_index < 7
    _mainCycle := (srcCyber - 2.0 * nz(srcCyber[1]) + nz(srcCyber[2])) / 4.0
else
    float _a1 = (1.0 - 0.5 * adaptiveAlpha) * (1.0 - 0.5 * adaptiveAlpha)
    float _a2 = 2.0 * (1.0 - adaptiveAlpha)
    float _a3 = (1.0 - adaptiveAlpha) * (1.0 - adaptiveAlpha)
    _mainCycle := _a1 * (_mainSmooth - 2.0 * nz(_mainSmooth[1]) + nz(_mainSmooth[2])) + _a2 * nz(_mainCycle[1]) - _a3 * nz(_mainCycle[2])

float cyberCycle = _mainCycle
float trigger = f_ema(cyberCycle, eTrigEma)

// iTrend — now per-coin alpha
var float _iTrend = 0.0
float _itA = eITrendAlpha
_iTrend := (_itA - _itA * _itA / 4.0) * close + 0.5 * _itA * _itA * nz(close[1]) - (_itA - 0.75 * _itA * _itA) * nz(close[2]) + 2.0 * (1.0 - _itA) * nz(_iTrend[1]) - (1.0 - _itA) * (1.0 - _itA) * nz(_iTrend[2])
float iTrend = _iTrend
bool bullTrend = iTrend > nz(iTrend[2])
bool bearTrend = iTrend < nz(iTrend[2])


// ╔══════════════════════════════════════════════════════════════════╗
// ║                     FISHER TRANSFORM                            ║
// ╚══════════════════════════════════════════════════════════════════╝

float _fH = ta.highest(cyberCycle, 10)
float _fL = ta.lowest(cyberCycle, 10)
float _fR = _fH - _fL
float _fV = _fR != 0 ? 2.0 * ((cyberCycle - _fL) / _fR - 0.5) : 0.0
_fV := math.max(-0.999, math.min(0.999, _fV))
float _fRaw = 0.5 * math.log((1.0 + _fV) / (1.0 - _fV))
var float fisherT = 0.0
fisherT := 0.5 * _fRaw + 0.5 * nz(fisherT[1])
bool fishRising  = fisherT > nz(fisherT[1])
bool fishFalling = fisherT < nz(fisherT[1])


// ╔══════════════════════════════════════════════════════════════════╗
// ║                     VOLUME FILTER                               ║
// ╚══════════════════════════════════════════════════════════════════╝

float volSma20   = ta.sma(volume, 20)
float volRatio   = volSma20 > 0 ? volume / volSma20 : 0
bool volumeOK    = not eUseVol or volRatio >= eVolMult


// ╔══════════════════════════════════════════════════════════════════╗
// ║                     HTF FILTER (4H)                             ║
// ╚══════════════════════════════════════════════════════════════════╝

float htfSrc  = request.security(syminfo.tickerid, "240", hl2, lookahead=barmerge.lookahead_off)
float htfCC   = request.security(syminfo.tickerid, "240",
     ta.ema(close, 10), lookahead=barmerge.lookahead_off)
bool htfBullish = not eUseHTF or htfSrc > htfCC
bool htfBearish = not eUseHTF or htfSrc < htfCC
bool htfAlignBuy  = not eUseHTF or htfBullish
bool htfAlignSell = not eUseHTF or htfBearish


// ╔══════════════════════════════════════════════════════════════════╗
// ║              REGIME FILTER COMPUTATIONS                          ║
// ║  Each filter independently determines if market is "tradeable"  ║
// ╚══════════════════════════════════════════════════════════════════╝

// ─── HELPER: ADX (Wilder's Average Directional Index) ───────────────
// Pine doesn't have ta.adx() built-in. Full Wilder implementation.
f_adx(int length) =>
    float _tr  = math.max(high - low, math.max(math.abs(high - nz(close[1])), math.abs(low - nz(close[1]))))
    float _pDM = math.max(high - nz(high[1]), 0.0)
    float _nDM = math.max(nz(low[1]) - low, 0.0)
    if _pDM > _nDM
        _nDM := 0.0
    else
        _pDM := 0.0
    float _strPDM = ta.rma(_pDM, length)
    float _strNDM = ta.rma(_nDM, length)
    float _strTR  = ta.rma(_tr,  length)
    float _pDI = 100.0 * _strPDM / math.max(_strTR, 1e-10)
    float _nDI = 100.0 * _strNDM / math.max(_strTR, 1e-10)
    float _sum = _pDI + _nDI
    float _dx  = _sum > 0.001 ? 100.0 * math.abs(_pDI - _nDI) / _sum : 0.0
    float _adx = ta.rma(_dx, length)
    _adx

// ─── P1: CYCLE AMPLITUDE FILTER ────────────────────────────────────
//  If the CyberCycle oscillation is tiny → there's no real cycle → ranging.
//  Measures peak-to-trough of recent cycle and compares to historical average.
float cycleHigh   = ta.highest(cyberCycle, 10)
float cycleLow    = ta.lowest (cyberCycle, 10)
float cycleAmp    = cycleHigh - cycleLow
float avgCycleAmp = ta.sma(cycleAmp, ampLookback)
float ampRatio    = avgCycleAmp > 1e-10 ? cycleAmp / avgCycleAmp : 1.0
bool  ampOK       = not useAmpFilter or ampRatio >= ampThreshold

// ─── P2: SQUEEZE FILTER (BB inside KC = volatility compression) ─────
//  When Bollinger Bands compress inside Keltner Channels, volatility
//  is at a minimum → market is coiling → ranging. Classic Carter concept.
float sqzBasis  = ta.sma(close, sqzLen)
float sqzDev    = sqzBBMult * ta.stdev(close, sqzLen)
float sqzBBU    = sqzBasis + sqzDev
float sqzBBL    = sqzBasis - sqzDev
float sqzATR    = ta.atr(sqzLen)
float sqzKCU    = sqzBasis + sqzKCMult * sqzATR
float sqzKCL    = sqzBasis - sqzKCMult * sqzATR
bool  inSqueeze = sqzBBL > sqzKCL and sqzBBU < sqzKCU
bool  sqzOK     = not useSqueeze or not inSqueeze

// ─── P3: ADX TREND STRENGTH ────────────────────────────────────────
//  Wilder's ADX measures directional movement strength.
//  ADX < threshold = no trend = ranging.
float adxValue = f_adx(adxLen)
bool  adxOK    = not useADX or adxValue >= adxMinVal

// ─── P4: CYCLE STRENGTH (Autocorrelation Peak Quality) ──────────────
//  The autocorrelation periodogram (already computed in f_autocorrelation)
//  returns the peak correlation at the dominant period.
//  Low correlation = no clear dominant cycle = noise/ranging.
//  _ac_peakCorr is available because all alpha methods run every bar.
bool  cycleStrOK = not useCycleStr or _ac_peakCorr >= minCycleCorr

// ─── P5: SNR FILTER (Signal-to-Noise Ratio in dB) ──────────────────
//  Signal power = the CyberCycle component (what we're trading on)
//  Noise power  = high-frequency residual (tick-to-tick changes)
//  If SNR is low → cycle is buried in noise → don't trade.
float sigPower    = cyberCycle * cyberCycle
float noiseRaw    = srcCyber - nz(srcCyber[1])
float noisePower  = noiseRaw * noiseRaw
float avgSigPow   = ta.sma(sigPower,  snrSmoothLen)
float avgNoisePow = ta.sma(noisePower, snrSmoothLen)
float snrRatio    = avgNoisePow > 1e-10 ? avgSigPow / avgNoisePow : 100.0
float snrDB       = 10.0 * math.log10(math.max(snrRatio, 0.001))
bool  snrOK       = not useSNR or snrDB >= snrMinDB

// ─── COMBINED REGIME VERDICT ────────────────────────────────────────
bool regimeOK = ampOK and sqzOK and adxOK and cycleStrOK and snrOK

// Count how many filters are active and passing (for info display)
int regimeActiveCount = 0
int regimePassCount   = 0
if useAmpFilter
    regimeActiveCount += 1
    if ampOK
        regimePassCount += 1
if useSqueeze
    regimeActiveCount += 1
    if sqzOK
        regimePassCount += 1
if useADX
    regimeActiveCount += 1
    if adxOK
        regimePassCount += 1
if useCycleStr
    regimeActiveCount += 1
    if cycleStrOK
        regimePassCount += 1
if useSNR
    regimeActiveCount += 1
    if snrOK
        regimePassCount += 1

// ╔══════════════════════════════════════════════════════════════════╗
// ║                     SIGNAL GENERATION                           ║
// ║  Now includes regime filter in confidence + final gate           ║
// ╚══════════════════════════════════════════════════════════════════╝

bool bullCross = ta.crossover(cyberCycle, trigger)
bool bearCross = ta.crossunder(cyberCycle, trigger)

bool inOB = cyberCycle > eOB
bool inOS = cyberCycle < eOS

float momentum3 = cyberCycle - nz(cyberCycle[3])

// ─── CONFIDENCE (now regime-aware) ───
// Base confidence: max 100 from original factors
// Regime bonus: +10 when all regime filters pass, -10 penalty when regime fails
float buyConf = 0.0
buyConf += bullCross ? 20.0 : 0.0
buyConf += (eUseTrend ? bullTrend : true) ? 15.0 : 0.0
buyConf += inOS ? 15.0 : 0.0
buyConf += (eUseVol ? volumeOK : true) ? 15.0 : 0.0
buyConf += fishRising ? 10.0 : 0.0
buyConf += momentum3 > 0 ? 10.0 : 0.0
buyConf += htfAlignBuy ? 15.0 : 0.0
// Regime modifier: reward trending regime, penalize ranging
buyConf += regimeOK ? 10.0 : -15.0
buyConf := math.max(0.0, math.min(buyConf, 100.0))

float sellConf = 0.0
sellConf += bearCross ? 20.0 : 0.0
sellConf += (eUseTrend ? bearTrend : true) ? 15.0 : 0.0
sellConf += inOB ? 15.0 : 0.0
sellConf += (eUseVol ? volumeOK : true) ? 15.0 : 0.0
sellConf += fishFalling ? 10.0 : 0.0
sellConf += momentum3 < 0 ? 10.0 : 0.0
sellConf += htfAlignSell ? 15.0 : 0.0
// Regime modifier
sellConf += regimeOK ? 10.0 : -15.0
sellConf := math.max(0.0, math.min(sellConf, 100.0))

// ─── BAR FILTER ───
var int lastSigBar = 0
bool barFilter = bar_index - lastSigBar >= eMinBars

// ─── FINAL SIGNALS (regime-gated) ───
bool buySignal  = bullCross and buyConf >= minConf and barFilter and (eUseTrend ? bullTrend : true) and htfAlignBuy and regimeOK
bool sellSignal = bearCross and sellConf >= minConf and barFilter and (eUseTrend ? bearTrend : true) and htfAlignSell and regimeOK

if buySignal or sellSignal
    lastSigBar := bar_index


// ╔══════════════════════════════════════════════════════════════════╗
// ║                     PRICE FORMAT HELPER                         ║
// ║  Auto-formats price based on magnitude for clean labels         ║
// ╚══════════════════════════════════════════════════════════════════╝

f_formatPrice(float p) =>
    string result = ""
    if p >= 10000
        result := str.tostring(p, "#")           // BTC: 98432
    else if p >= 100
        result := str.tostring(p, "#.#")          // ETH/SOL: 3421.5
    else if p >= 1
        result := str.tostring(p, "#.##")         // Mid-caps: 12.45
    else if p >= 0.01
        result := str.tostring(p, "#.####")       // Low: 0.1234
    else
        result := str.tostring(p, "#.######")     // Micro: 0.000123
    result


// ╔══════════════════════════════════════════════════════════════════╗
// ║                     VISUALIZATION                               ║
// ╚══════════════════════════════════════════════════════════════════╝

grp_viz = "══════ VISUALIZATION ══════"
showITrend      = input.bool(true,  "Show iTrend",        group=grp_viz)
showCloud       = input.bool(true,  "Show Cloud",         group=grp_viz)
showBuySignals  = input.bool(true,  "Show BUY Signals",   group=grp_viz)
showSellSignals = input.bool(true,  "Show SELL Signals",  group=grp_viz)
showInfoTable   = input.bool(true,  "Show Info Table",    group=grp_viz)
showRegimeBG    = input.bool(true,  "Show Regime BG",     group=grp_viz,
     tooltip="Yellow background tint when regime filters detect ranging.\nHelps visualize when the system is paused.")
cloudAtrLen     = input.int(14,     "Cloud ATR Len",      group=grp_viz)
cloudAtrMult    = input.float(1.5,  "Cloud ATR Mult",     group=grp_viz)

color bullColor = #00C853
color bearColor = #FF1744

float atr = ta.atr(cloudAtrLen)
float cloudUpper = iTrend + atr * cloudAtrMult
float cloudLower = iTrend - atr * cloudAtrMult

plot(showITrend ? iTrend : na, "ITrend", color=bullTrend ? bullColor : bearColor, linewidth=2)
pU = plot(showCloud ? cloudUpper : na, "Cloud Upper", color=color.new(color.gray, 90))
pL = plot(showCloud ? cloudLower : na, "Cloud Lower", color=color.new(color.gray, 90))
pM = plot(showCloud ? iTrend : na, "Cloud Mid", color=na)
fill(pU, pM, color=bullTrend ? color.new(bullColor, 85) : color.new(bearColor, 85), title="Upper Fill")
fill(pM, pL, color=bullTrend ? color.new(bullColor, 85) : color.new(bearColor, 85), title="Lower Fill")

// ─── REAL-TIME PRICE CAPTURE ───
// varip persists across ticks within the SAME bar (real-time only).
// On historical bars, varip behaves like var → we fall back to hl2.
//
// Logic:
//   Real-time: first tick where signal=true → capture close (= tick price)
//   Historical: no tick data exists → use srcCyber (hl2) as best proxy
//
varip float  capturedBuyPrice  = na
varip float  capturedSellPrice = na
varip bool   buyPriceLocked    = false
varip bool   sellPriceLocked   = false

// Reset locks at the start of each new bar
if barstate.isnew
    capturedBuyPrice  := na
    capturedSellPrice := na
    buyPriceLocked    := false
    sellPriceLocked   := false

// Capture the FIRST tick where the signal fires (real-time)
if buySignal and not buyPriceLocked
    capturedBuyPrice := barstate.ishistory ? srcCyber : close  // close on live tick = exact price
    buyPriceLocked   := true

if sellSignal and not sellPriceLocked
    capturedSellPrice := barstate.ishistory ? srcCyber : close
    sellPriceLocked   := true

// ─── SIGNAL LABELS WITH CAPTURED PRICE ───
if showBuySignals and buySignal
    float displayPrice = not na(capturedBuyPrice) ? capturedBuyPrice : srcCyber
    string priceStr = f_formatPrice(displayPrice)
    string liveTag  = barstate.isrealtime ? " ●" : ""  // dot = real-time captured
    label.new(bar_index, low, "BUY\n" + priceStr + liveTag, 
         style=label.style_label_up, color=bullColor, textcolor=color.white, size=size.normal)

if showSellSignals and sellSignal
    float displayPrice = not na(capturedSellPrice) ? capturedSellPrice : srcCyber
    string priceStr = f_formatPrice(displayPrice)
    string liveTag  = barstate.isrealtime ? " ●" : ""
    label.new(bar_index, high, "SELL\n" + priceStr + liveTag, 
         style=label.style_label_down, color=bearColor, textcolor=color.white, size=size.normal)

// ─── WEAK SIGNALS (small dots, no price — keep clean) ───
bool weakBuy = bullCross and buyConf >= 30 and buyConf < minConf and barFilter and htfAlignBuy and regimeOK
bool weakSell = bearCross and sellConf >= 30 and sellConf < minConf and barFilter and htfAlignSell and regimeOK
plotshape(showBuySignals and weakBuy, "Weak Buy", shape.circle, location.belowbar, color.new(bullColor, 50), size=size.tiny)
plotshape(showSellSignals and weakSell, "Weak Sell", shape.circle, location.abovebar, color.new(bearColor, 50), size=size.tiny)
barcolor(cyberCycle > trigger and bullTrend ? bullColor : cyberCycle < trigger and bearTrend ? bearColor : na)

// ─── REGIME BACKGROUND (subtle warning when ranging) ───
color regimeBG = showRegimeBG and not regimeOK ? color.new(color.yellow, 92) : na
bgcolor(regimeBG, title="Regime Warning", editable=true)


// ╔══════════════════════════════════════════════════════════════════╗
// ║                     INFO TABLE                                  ║
// ╚══════════════════════════════════════════════════════════════════╝

if showInfoTable and barstate.islast
    var table t = table.new(position.top_right, 2, 15, bgcolor=color.new(color.black, 70), border_width=1, border_color=color.gray)
    int row = 0

    table.cell(t, 0, row, "Method", text_color=color.white, text_size=size.small)
    table.cell(t, 1, row, eAlphaMethod + "  α=" + str.tostring(adaptiveAlpha, "#.###") + "  P=" + str.tostring(dominantPeriod, "#.#"), text_color=color.yellow, text_size=size.small)
    row += 1
    table.cell(t, 0, row, "Coin", text_color=color.white, text_size=size.small)
    table.cell(t, 1, row, detectedCoin + (eAFloor > 0 ? "  floor=" + str.tostring(eAFloor, "#.##") : "") + "  iT=" + str.tostring(eITrendAlpha, "#.##"), text_color=color.yellow, text_size=size.small)
    row += 1
    table.cell(t, 0, row, "Cycle", text_color=color.white, text_size=size.small)
    table.cell(t, 1, row, str.tostring(cyberCycle, "#.####"), text_color=cyberCycle > 0 ? bullColor : bearColor, text_size=size.small)
    row += 1
    table.cell(t, 0, row, "Trend", text_color=color.white, text_size=size.small)
    table.cell(t, 1, row, (bullTrend ? "BULL" : bearTrend ? "BEAR" : "FLAT") + (eUseTrend ? "" : " [OFF]"), text_color=bullTrend ? bullColor : bearTrend ? bearColor : color.gray, text_size=size.small)
    row += 1
    table.cell(t, 0, row, "Zone", text_color=color.white, text_size=size.small)
    table.cell(t, 1, row, inOB ? "OVERBOUGHT" : inOS ? "OVERSOLD" : "NEUTRAL", text_color=inOB ? bearColor : inOS ? bullColor : color.gray, text_size=size.small)
    row += 1
    table.cell(t, 0, row, "Direction", text_color=color.white, text_size=size.small)
    table.cell(t, 1, row, cyberCycle > trigger ? "BULLISH" : "BEARISH", text_color=cyberCycle > trigger ? bullColor : bearColor, text_size=size.small)
    row += 1
    float cConf = bullCross ? buyConf : bearCross ? sellConf : 0
    table.cell(t, 0, row, "Confidence", text_color=color.white, text_size=size.small)
    table.cell(t, 1, row, cConf > 0 ? str.tostring(cConf, "#") + "% (min " + str.tostring(minConf, "#") + "%)" : "---", text_color=cConf >= minConf ? bullColor : cConf >= 30 ? color.yellow : color.gray, text_size=size.small)
    row += 1
    table.cell(t, 0, row, eUseVol ? "Volume" : "Vol [OFF]", text_color=color.white, text_size=size.small)
    table.cell(t, 1, row, eUseVol ? (volumeOK ? "OK" : "LOW") : "---", text_color=volumeOK ? bullColor : color.gray, text_size=size.small)
    row += 1
    table.cell(t, 0, row, eUseHTF ? "HTF 4H" : "HTF [OFF]", text_color=color.white, text_size=size.small)
    table.cell(t, 1, row, eUseHTF ? (htfBullish ? "BULL" : "BEAR") : "---", text_color=htfBullish ? bullColor : bearColor, text_size=size.small)
    row += 1

    // ─── REGIME FILTERS STATUS ───
    string regimeStr = regimeOK ? "TRENDING" : "RANGING"
    string regimeDet = str.tostring(regimePassCount) + "/" + str.tostring(regimeActiveCount) + " pass"
    color  regimeCol = regimeOK ? bullColor : color.yellow
    table.cell(t, 0, row, "Regime", text_color=color.white, text_size=size.small)
    table.cell(t, 1, row, regimeActiveCount > 0 ? regimeStr + "  " + regimeDet : "ALL OFF", text_color=regimeActiveCount > 0 ? regimeCol : color.gray, text_size=size.small)
    row += 1

    // Individual filter details (compact single row)
    string fDet = ""
    fDet += useAmpFilter ? ("Amp:" + (ampOK ? "✓" : "✗") + str.tostring(ampRatio, "#.##") + " ") : ""
    fDet += useSqueeze   ? ("Sqz:" + (sqzOK ? "✓" : "✗") + " ") : ""
    fDet += useADX       ? ("ADX:" + (adxOK ? "✓" : "✗") + str.tostring(adxValue, "#.#") + " ") : ""
    fDet += useCycleStr  ? ("Cyc:" + (cycleStrOK ? "✓" : "✗") + str.tostring(_ac_peakCorr, "#.##") + " ") : ""
    fDet += useSNR       ? ("SNR:" + (snrOK ? "✓" : "✗") + str.tostring(snrDB, "#.#") + "dB") : ""
    table.cell(t, 0, row, "Filters", text_color=color.white, text_size=size.small)
    table.cell(t, 1, row, fDet != "" ? fDet : "none active", text_color=regimeOK ? color.gray : color.yellow, text_size=size.tiny)
    row += 1

    table.cell(t, 0, row, "Config", text_color=color.white, text_size=size.small)
    table.cell(t, 1, row, "T=" + str.tostring(eTrigEma) + " B=" + str.tostring(eMinBars) + " OB=" + str.tostring(eOB, "#.#") + " OS=" + str.tostring(eOS, "#.#"), text_color=color.white, text_size=size.small)
    row += 1
    // All alpha methods running for transparency
    table.cell(t, 0, row, "All α", text_color=color.white, text_size=size.small)
    table.cell(t, 1, row, "HD=" + str.tostring(_a_hd, "#.###") + " MA=" + str.tostring(_a_ma, "#.###") + " AC=" + str.tostring(_a_ac, "#.###") + " KL=" + str.tostring(_a_kl, "#.###"), text_color=color.gray, text_size=size.small)


// ╔══════════════════════════════════════════════════════════════════╗
// ║                     ALERTS                                      ║
// ╚══════════════════════════════════════════════════════════════════╝

alertcondition(buySignal, "Buy v7.0", "CC v7.0: BUY Signal (regime OK)")
alertcondition(sellSignal, "Sell v7.0", "CC v7.0: SELL Signal (regime OK)")
alertcondition(bullCross, "Bull Cross", "CC v7.0: Bull Cross (unfiltered)")
alertcondition(bearCross, "Bear Cross", "CC v7.0: Bear Cross (unfiltered)")
alertcondition(not regimeOK and regimeOK[1], "Regime → RANGING", "CC v7.0: Market entered RANGING regime")
alertcondition(regimeOK and not regimeOK[1], "Regime → TRENDING", "CC v7.0: Market returned to TRENDING regime")
