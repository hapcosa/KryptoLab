//@version=5
// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘   SMC PURE OSCILLATOR                                              â•‘
// â•‘   v7.4 â€” Anti-Phantom Edition                                      â•‘
// â•‘                                                                      â•‘
// â•‘  FIX vs v7.3:                                                        â•‘
// â•‘   ğŸ”´ PROTECTED BREAKS: CHoCH/BOS/Sweep transitions only commit    â•‘
// â•‘      on confirmed bars. Prevents phantom ticks from permanently    â•‘
// â•‘      corrupting the structural state machine. The oscillator       â•‘
// â•‘      (struct_pos, ob_pressure) still moves in real-time because   â•‘
// â•‘      it uses close against FIXED confirmed levels. (Optional)     â•‘
// â•‘   ğŸ”´ SIGNAL PERSISTENCE: crossover must survive N seconds or      â•‘
// â•‘      N ticks before activating. Phantom crossovers that die       â•‘
// â•‘      in 1-2 ticks are completely ignored. (Optional)              â•‘
// â•‘   ğŸ”´ GHOST COOLDOWN FIX: cooldown only updates when a signal     â•‘
// â•‘      passes persistence. Phantom signals can't block future ones. â•‘
// â•‘                                                                      â•‘
// â•‘  From v7.3:                                                          â•‘
// â•‘   âœ… EDGE DETECTION: HTF events use rising edge detection.        â•‘
// â•‘   âœ… SEÃ‘ALES EN CHART: L2/L3 on price chart via force_overlay.    â•‘
// â•‘                                                                      â•‘
// â•‘  Arquitectura:                                                        â•‘
// â•‘   Oscilador = TF actual (PositionÃ—60% + OB ProxÃ—40%)             â•‘
// â•‘   HTFs = solo filtro de trend para L2/L3                           â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
indicator("SMC Pure Oscillator",
     shorttitle       = "SMCÂ·v7.4",
     overlay          = false,
     max_labels_count = 200)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HTF AUTO-RELATIVO
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
f_auto_htf() =>
    int sec = timeframe.in_seconds()
    string h1 = ""
    string h2 = ""
    if sec <= 300
        h1 := "15"
        h2 := "60"
    else if sec <= 900
        h1 := "60"
        h2 := "240"
    else if sec <= 2700
        h1 := "120"
        h2 := "480"
    else if sec <= 3600
        h1 := "240"
        h2 := "1D"
    else if sec <= 7200
        h1 := "480"
        h2 := "1D"
    else if sec <= 14400
        h1 := "1D"
        h2 := "1W"
    else if sec <= 86400
        h1 := "1W"
        h2 := "1M"
    else
        h1 := "1M"
        h2 := "3M"
    [h1, h2]

[auto_htf1, auto_htf2] = f_auto_htf()

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INPUTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
grp_s   = "âš™ï¸  Estructura SMC"
grp_htf = "ğŸ• HTF Filtro (solo trend)"
grp_fus = "ğŸ”— FusiÃ³n"
grp_sig = "ğŸ¯ SeÃ±ales"
grp_vis = "ğŸ‘ Visual"
grp_c   = "ğŸ¨ Colores"

int  swingLen   = input.int (5,    "Swing Length",  minval=2, maxval=15, group=grp_s)
bool useSweep   = input.bool(true, "Sweeps",                             group=grp_s)
int  obLookback = input.int (5,    "OB Lookback",   minval=2, maxval=20, group=grp_s)

bool   htf_en   = input.bool (true, "Activar Filtro HTF",                group=grp_htf)
string htf_mode = input.string("1 HTF", "HTFs requeridos",               group=grp_htf,
     options=["1 HTF", "2 HTFs"],
     tooltip="1 HTF: solo HTF Medio debe confirmar.\n2 HTFs: ambos (Medio + Alto) deben confirmar.\n1 HTF es menos restrictivo â†’ mÃ¡s seÃ±ales L2/L3.")
bool   htf_auto = input.bool (true, "Auto-Detectar HTFs",                group=grp_htf)
string htf1_man = input.timeframe("1D", "HTF Medio (manual)",            group=grp_htf)
string htf2_man = input.timeframe("1W", "HTF Alto (manual)",             group=grp_htf)

float  wA       = input.float(0.6, "Peso Capa A (Position)", minval=0.0, maxval=1.0, step=0.05, group=grp_fus)
float  wB       = input.float(0.4, "Peso Capa B (OB Prox)",  minval=0.0, maxval=1.0, step=0.05, group=grp_fus)
int    smoothL  = input.int  (5,   "Suavizado EMA",           minval=1, maxval=30, group=grp_fus)
int    trigL    = input.int  (8,   "Trigger EMA",              minval=2, maxval=30, group=grp_fus)

int   eventWin  = input.int (5,  "Event Window",   minval=1,  maxval=20, group=grp_sig)
int   sigCool   = input.int (5,  "Signal Cooldown", minval=1, maxval=30, group=grp_sig,
     tooltip="MÃ­nimo de barras entre seÃ±ales del mismo tipo.")
bool  showL1    = input.bool(false,"L1: Cruce Main/Trig",               group=grp_sig)
bool  showL2    = input.bool(true, "L2: Cruce + HTF trend",             group=grp_sig)
bool  showL3    = input.bool(true, "L3: Cruce + HTF + evento SMC",      group=grp_sig)
bool  showChart = input.bool(true, "SeÃ±ales en Chart",                  group=grp_sig,
     tooltip="Muestra L2/L3 sobre el grÃ¡fico de precio.")
bool  showEvOsc = input.bool(true, "Eventos en Oscilador",              group=grp_sig)

grp_prot = "ğŸ›¡ Anti-Phantom"
bool   useProtBreaks = input.bool (true, "â‘  Protected Breaks", group=grp_prot,
     tooltip="Las transiciones estructurales CRÃTICAS (CHoCH, BOS, Sweeps) solo se commitean cuando la barra cierra.\n\nEl oscilador sigue moviÃ©ndose en tiempo real porque usa close contra niveles FIJOS confirmados. Solo los eventos esperan confirmaciÃ³n.\n\nRecomendado: ON siempre. Previene corrupciÃ³n permanente del estado estructural por ticks phantomas.")
bool   usePersist    = input.bool (true, "â‘¡ Signal Persistence", group=grp_prot,
     tooltip="El crossover smc_main/smc_trig debe sobrevivir continuamente N segundos (o N ticks) antes de activar una seÃ±al.\n\nPhantom crossovers que mueren en 1-2 ticks se ignoran completamente.\n\nRecomendado: ON con 3-5 segundos para 1H+.")
string persistMode   = input.string("Time", "  Persist Mode", options=["Time", "Ticks"], group=grp_prot,
     tooltip="Time: determinÃ­stico, independiente del tick rate.\nTicks: mÃ¡s simple pero variable con actividad del mercado.")
float  persistSec    = input.float(3.0, "  Persist Seconds", minval=1.0, maxval=30.0, step=1.0, group=grp_prot,
     tooltip="Segundos que el crossover debe mantenerse verdadero.\n3s = bueno para 1H+ (filtra spikes rÃ¡pidos).\n5s = conservador.\n2s = agresivo.")
int    persistTicks  = input.int  (5,   "  Persist Ticks",   minval=2,   maxval=30,             group=grp_prot,
     tooltip="Ticks consecutivos requeridos.\n5 = balanceado, 3 = agresivo, 8-10 = conservador.")

bool showHist   = input.bool(true,  "Histograma",               group=grp_vis)
bool showTrig   = input.bool(true,  "Trigger Line",             group=grp_vis)
bool showCapaA  = input.bool(false, "Capa A: Position (diag)",  group=grp_vis)
bool showCapaB  = input.bool(false, "Capa B: OB Prox (diag)",   group=grp_vis)
bool showTable  = input.bool(true,  "Tabla Estado",             group=grp_vis)

color bullCol  = input.color(#089981, "Alcista",  group=grp_c)
color bearCol  = input.color(#f23645, "Bajista",  group=grp_c)
color sweepCol = input.color(#f0b429, "Sweep",    group=grp_c)
color trigCol  = input.color(color.new(#ffffff, 45), "Trigger", group=grp_c)

string htf1 = htf_auto ? auto_htf1 : htf1_man
string htf2 = htf_auto ? auto_htf2 : htf2_man

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MÃQUINA SMC COMPLETA
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
f_smc_full(int swing_len, bool use_sweep, int ob_lb, bool protected) =>
    // canBreak = gate for IRREVERSIBLE state transitions.
    // When protected=true, only commits structural changes on confirmed bars.
    // When protected=false, original v7.3 behavior (every tick).
    // The oscillator (struct_pos, ob_pressure) still uses live close against
    // FIXED confirmed levels â†’ real-time movement is preserved.
    bool canBreak = not protected or barstate.isconfirmed or barstate.ishistory

    float ph = ta.pivothigh(high, swing_len, swing_len)
    float pl = ta.pivotlow (low,  swing_len, swing_len)
    var float last_ph = na
    var float last_pl = na
    if not na(ph)
        last_ph := ph
    if not na(pl)
        last_pl := pl

    var int   ms_trend = 1
    var float ms_bos   = na
    var float ms_choch = na
    var float ms_main  = high
    bool ev_cb = false
    bool ev_cr = false
    bool ev_bb = false
    bool ev_br = false
    bool ev_su = false
    bool ev_sd = false

    if ms_trend == 1
        if high > nz(ms_main, high)
            ms_main := high
        // BOS level formation: 2 bearish candles â†’ set BOS target
        // Protected because phantom close<open can set a false BOS level
        // which then cascades into a false BOS break
        bool cdn = close < open and close[1] < open[1]
        if na(ms_bos) and cdn and canBreak
            ms_bos := ms_main
        // Sweep down: price wicks below CHoCH but closes above â†’ level adjustment
        if use_sweep and not na(ms_choch) and canBreak
            if low <= ms_choch and close > ms_choch
                ev_sd    := true
                ms_choch := low
        // Sweep up: price wicks above BOS but closes below â†’ level adjustment
        if use_sweep and not na(ms_bos) and canBreak
            if high >= ms_bos and close < ms_bos
                ev_su  := true
                ms_bos := high
        // BOS BREAK: close confirms above BOS level
        // CRITICAL â€” reasigns choch, clears bos, resets main
        if not na(ms_bos) and close >= ms_bos and canBreak
            ev_bb    := true
            ms_choch := not na(last_pl) ? last_pl : ms_main * 0.99
            ms_bos   := na
            ms_main  := high
        // CHoCH BREAK: close confirms below CHoCH level
        // CRITICAL â€” FLIPS ms_trend, reasigns ALL levels
        if not na(ms_choch) and close <= ms_choch and canBreak
            ev_cr    := true
            ms_trend := -1
            ms_choch := not na(last_ph) ? last_ph : ms_main
            ms_main  := low
            ms_bos   := na

    if ms_trend == -1
        if low < nz(ms_main, low)
            ms_main := low
        bool cup = close > open and close[1] > open[1]
        if na(ms_bos) and cup and canBreak
            ms_bos := ms_main
        if use_sweep and not na(ms_choch) and canBreak
            if high >= ms_choch and close < ms_choch
                ev_su    := true
                ms_choch := high
        if use_sweep and not na(ms_bos) and canBreak
            if low <= ms_bos and close > ms_bos
                ev_sd  := true
                ms_bos := low
        // BOS BREAK (bearish)
        if not na(ms_bos) and close <= ms_bos and canBreak
            ev_br    := true
            ms_choch := not na(last_ph) ? last_ph : ms_main * 1.01
            ms_bos   := na
            ms_main  := low
        // CHoCH BREAK (bearish â†’ bullish)
        if not na(ms_choch) and close >= ms_choch and canBreak
            ev_cb    := true
            ms_trend := 1
            ms_choch := not na(last_pl) ? last_pl : ms_main
            ms_main  := high
            ms_bos   := na

    // Order Blocks
    var float bull_ob_top = na
    var float bull_ob_btm = na
    var float bear_ob_top = na
    var float bear_ob_btm = na
    if ev_bb or ev_cb
        for i = 1 to ob_lb
            if close[i] < open[i]
                bull_ob_top := high[i]
                bull_ob_btm := low [i]
                break
    if ev_br or ev_cr
        for i = 1 to ob_lb
            if close[i] > open[i]
                bear_ob_top := high[i]
                bear_ob_btm := low [i]
                break
    if not na(bull_ob_btm) and low  < bull_ob_btm
        bull_ob_top := na
        bull_ob_btm := na
    if not na(bear_ob_top) and high > bear_ob_top
        bear_ob_top := na
        bear_ob_btm := na

    // Capa A â€” Structural Position
    float struct_pos = 0.0
    float _choch = nz(ms_choch, close)
    float _main  = nz(ms_main,  close)
    float _range = math.abs(_main - _choch)
    float _atr   = ta.atr(14)
    float safe_range = math.max(_range, _atr * 0.5)
    if ms_trend == 1
        float raw_pos = (close - _choch) / safe_range
        struct_pos := math.max(-1.5, math.min(1.5, raw_pos)) * 100.0
    else
        float raw_pos = (_choch - close) / safe_range
        struct_pos := math.max(-1.5, math.min(1.5, raw_pos)) * -100.0

    // Capa B â€” OB Proximity (trend-aware v7.2)
    float ob_pressure = 0.0
    float safe_atr = math.max(_atr, 0.0001)
    bool has_bull_ob = not na(bull_ob_btm) and not na(bull_ob_top)
    bool has_bear_ob = not na(bear_ob_btm) and not na(bear_ob_top)
    if has_bull_ob and has_bear_ob
        float bull_mid = math.avg(bull_ob_top, bull_ob_btm)
        float bear_mid = math.avg(bear_ob_top, bear_ob_btm)
        float dist_bull = math.abs(close - bull_mid) / safe_atr
        float dist_bear = math.abs(close - bear_mid) / safe_atr
        float total = dist_bull + dist_bear
        if total > 0.001
            ob_pressure := ((dist_bear - dist_bull) / total) * 100.0
        if close >= bull_ob_btm and close <= bull_ob_top
            ob_pressure := math.max(ob_pressure, 50.0)
        if close >= bear_ob_btm and close <= bear_ob_top
            ob_pressure := math.min(ob_pressure, -50.0)
    else if has_bull_ob and not has_bear_ob
        float bull_mid = math.avg(bull_ob_top, bull_ob_btm)
        float dist = math.abs(close - bull_mid) / safe_atr
        float proximity = math.max(0.0, 1.0 - dist / 5.0)
        if ms_trend == 1
            ob_pressure := proximity * 30.0
            if close >= bull_ob_btm and close <= bull_ob_top
                ob_pressure := 40.0
        else
            ob_pressure := proximity * 15.0 - 15.0
            if close >= bull_ob_btm and close <= bull_ob_top
                ob_pressure := 20.0
    else if has_bear_ob and not has_bull_ob
        float bear_mid = math.avg(bear_ob_top, bear_ob_btm)
        float dist = math.abs(close - bear_mid) / safe_atr
        float proximity = math.max(0.0, 1.0 - dist / 5.0)
        if ms_trend == -1
            ob_pressure := -proximity * 30.0
            if close >= bear_ob_btm and close <= bear_ob_top
                ob_pressure := -40.0
        else
            ob_pressure := -proximity * 15.0 + 15.0
            if close >= bear_ob_btm and close <= bear_ob_top
                ob_pressure := -20.0

    struct_pos  := math.max(-100.0, math.min(100.0, struct_pos))
    ob_pressure := math.max(-100.0, math.min(100.0, ob_pressure))
    [struct_pos, ob_pressure, ms_trend, ev_cb, ev_cr, ev_bb, ev_br, ev_su, ev_sd]

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FUNCIÃ“N LIGERA SOLO TREND (HTFs)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
f_smc_trend(int swing_len, bool use_sweep) =>
    float ph = ta.pivothigh(high, swing_len, swing_len)
    float pl = ta.pivotlow (low,  swing_len, swing_len)
    var float last_ph = na
    var float last_pl = na
    if not na(ph)
        last_ph := ph
    if not na(pl)
        last_pl := pl
    var int   ms_trend = 1
    var float ms_bos   = na
    var float ms_choch = na
    var float ms_main  = high
    bool ev_cb = false
    bool ev_cr = false
    if ms_trend == 1
        if high > nz(ms_main, high)
            ms_main := high
        bool cdn = close < open and close[1] < open[1]
        if na(ms_bos) and cdn
            ms_bos := ms_main
        if use_sweep and not na(ms_choch)
            if low <= ms_choch and close > ms_choch
                ms_choch := low
        if use_sweep and not na(ms_bos)
            if high >= ms_bos and close < ms_bos
                ms_bos := high
        if not na(ms_bos) and close >= ms_bos
            ms_choch := not na(last_pl) ? last_pl : ms_main * 0.99
            ms_bos   := na
            ms_main  := high
        if not na(ms_choch) and close <= ms_choch
            ev_cr    := true
            ms_trend := -1
            ms_choch := not na(last_ph) ? last_ph : ms_main
            ms_main  := low
            ms_bos   := na
    if ms_trend == -1
        if low < nz(ms_main, low)
            ms_main := low
        bool cup = close > open and close[1] > open[1]
        if na(ms_bos) and cup
            ms_bos := ms_main
        if use_sweep and not na(ms_choch)
            if high >= ms_choch and close < ms_choch
                ms_choch := high
        if use_sweep and not na(ms_bos)
            if low <= ms_bos and close > ms_bos
                ms_bos := low
        if not na(ms_bos) and close <= ms_bos
            ms_choch := not na(last_ph) ? last_ph : ms_main * 1.01
            ms_bos   := na
            ms_main  := low
        if not na(ms_choch) and close >= ms_choch
            ev_cb    := true
            ms_trend := 1
            ms_choch := not na(last_pl) ? last_pl : ms_main
            ms_main  := high
            ms_bos   := na
    [ms_trend, ev_cb, ev_cr]

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// EJECUCIÃ“N
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
[posA0, obP0, tr0, cb0, cr0, bb0, br0, su0, sd0] = f_smc_full(swingLen, useSweep, obLookback, useProtBreaks)
[tr1, cb1, cr1] = request.security(syminfo.tickerid, htf1, f_smc_trend(swingLen, useSweep), lookahead=barmerge.lookahead_off)
[tr2, cb2, cr2] = request.security(syminfo.tickerid, htf2, f_smc_trend(swingLen, useSweep), lookahead=barmerge.lookahead_off)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// OSCILADOR
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
float wt = wA + wB
float raw_osc = wt > 0 ? (posA0 * wA + obP0 * wB) / wt : posA0
float raw_clamped = math.max(-100.0, math.min(100.0, raw_osc))
float smc_main = ta.ema(raw_clamped, smoothL)
float smc_trig = ta.ema(raw_clamped, trigL)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// EDGE DETECTION â€” TODOS LOS EVENTOS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HTF: request.security mantiene true durante varias barras del TF actual.
// Edge = true SOLO en la primera barra donde cambia de false a true.
bool htf_cb1_edge = cb1 and not nz(cb1[1], false)
bool htf_cr1_edge = cr1 and not nz(cr1[1], false)
bool htf_cb2_edge = cb2 and not nz(cb2[1], false)
bool htf_cr2_edge = cr2 and not nz(cr2[1], false)
bool htf_choch_b  = htf_cb1_edge or htf_cb2_edge
bool htf_choch_r  = htf_cr1_edge or htf_cr2_edge

// TF actual: eventos ya son single-bar por diseÃ±o, pero aplicamos cooldown
bool ev_choch_bull = cb0
bool ev_choch_bear = cr0
bool ev_bos_bull   = bb0
bool ev_bos_bear   = br0
bool ev_sweep_up   = su0
bool ev_sweep_dn   = sd0

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SEÃ‘ALES CON PERSISTENCE + GHOST-PROOF COOLDOWN
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
bool htf_bull   = not htf_en ? true : htf_mode == "2 HTFs" ? (tr1 == 1  and tr2 == 1)  : (tr1 == 1)
bool htf_bear   = not htf_en ? true : htf_mode == "2 HTFs" ? (tr1 == -1 and tr2 == -1) : (tr1 == -1)
bool align_bull = tr0 == 1  and htf_bull
bool align_bear = tr0 == -1 and htf_bear

bool bull_cross = ta.crossover (smc_main, smc_trig)
bool bear_cross = ta.crossunder(smc_main, smc_trig)

int bs_bull = ta.barssince(ev_choch_bull or ev_bos_bull)
int bs_bear = ta.barssince(ev_choch_bear or ev_bos_bear)
bool recent_bull_ev = not na(bs_bull) and bs_bull <= eventWin
bool recent_bear_ev = not na(bs_bear) and bs_bear <= eventWin

bool raw_L1_long  = bull_cross
bool raw_L1_short = bear_cross
bool raw_L2_long  = bull_cross and htf_bull
bool raw_L2_short = bear_cross and htf_bear
bool raw_L3_long  = raw_L2_long  and recent_bull_ev
bool raw_L3_short = raw_L2_short and recent_bear_ev

// â”€â”€â”€ GHOST-PROOF COOLDOWN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Only updates when a signal PASSES persistence.
// Phantom signals that die before threshold â†’ zero impact.
var int cd_L1l = 999
var int cd_L1s = 999
var int cd_L2l = 999
var int cd_L2s = 999
var int cd_L3l = 999
var int cd_L3s = 999
cd_L1l += 1
cd_L1s += 1
cd_L2l += 1
cd_L2s += 1
cd_L3l += 1
cd_L3s += 1

// Apply cooldown gate to raw signals BEFORE persistence
bool gated_L1_long  = raw_L1_long  and cd_L1l > sigCool
bool gated_L1_short = raw_L1_short and cd_L1s > sigCool
bool gated_L2_long  = raw_L2_long  and cd_L2l > sigCool
bool gated_L2_short = raw_L2_short and cd_L2s > sigCool
bool gated_L3_long  = raw_L3_long  and cd_L3l > sigCool
bool gated_L3_short = raw_L3_short and cd_L3s > sigCool

// â”€â”€â”€ PERSISTENCE ENGINE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// The crossover must survive continuously for N seconds or N ticks
// before the signal activates. Once persisted â†’ locked ON for rest
// of bar. Phantom crossovers that die in 1-2 ticks are ignored.
//
// We track persistence for the HIGHEST qualifying level.
// If L3 persists, L2 and L1 are implicitly persisted too.
// If L2 persists but not L3, only L2 and L1 fire.
//
// On historical bars: persistence is instant (1 tick per bar).
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Bull side
varip int  bull_pTicks    = 0
varip int  bull_pTime     = 0
varip bool bull_persisted = false
varip int  bull_maxLevel  = 0    // highest level that qualified: 1, 2, or 3

// Bear side
varip int  bear_pTicks    = 0
varip int  bear_pTime     = 0
varip bool bear_persisted = false
varip int  bear_maxLevel  = 0

// Reset at start of each new bar
if barstate.isnew
    bull_pTicks    := 0
    bull_pTime     := 0
    bull_persisted := false
    bull_maxLevel  := 0
    bear_pTicks    := 0
    bear_pTime     := 0
    bear_persisted := false
    bear_maxLevel  := 0

// Determine if ANY bull crossover signal is active this tick
bool anyBullGated = gated_L1_long or gated_L2_long or gated_L3_long
bool anyBearGated = gated_L1_short or gated_L2_short or gated_L3_short

// Track highest qualifying level this tick
int currBullLevel = gated_L3_long ? 3 : gated_L2_long ? 2 : gated_L1_long ? 1 : 0
int currBearLevel = gated_L3_short ? 3 : gated_L2_short ? 2 : gated_L1_short ? 1 : 0

// â”€â”€ BULL persistence â”€â”€
if anyBullGated and not bull_persisted
    bull_pTicks += 1
    if bull_pTime == 0
        bull_pTime := timenow
    // Track highest level seen during persistence window
    if currBullLevel > bull_maxLevel
        bull_maxLevel := currBullLevel
    // Check persistence threshold
    bool histPass = barstate.ishistory
    bool tickOK   = usePersist and persistMode == "Ticks" and bull_pTicks >= persistTicks
    bool timeOK   = usePersist and persistMode == "Time"  and bull_pTime > 0 and (timenow - bull_pTime) >= persistSec * 1000
    bool offOK    = not usePersist
    if histPass or tickOK or timeOK or offOK
        bull_persisted := true
else if not anyBullGated and not bull_persisted
    // Crossover died before persistence â†’ phantom â†’ full reset
    bull_pTicks   := 0
    bull_pTime    := 0
    bull_maxLevel := 0

// â”€â”€ BEAR persistence â”€â”€
if anyBearGated and not bear_persisted
    bear_pTicks += 1
    if bear_pTime == 0
        bear_pTime := timenow
    if currBearLevel > bear_maxLevel
        bear_maxLevel := currBearLevel
    bool histPass = barstate.ishistory
    bool tickOK   = usePersist and persistMode == "Ticks" and bear_pTicks >= persistTicks
    bool timeOK   = usePersist and persistMode == "Time"  and bear_pTime > 0 and (timenow - bear_pTime) >= persistSec * 1000
    bool offOK    = not usePersist
    if histPass or tickOK or timeOK or offOK
        bear_persisted := true
else if not anyBearGated and not bear_persisted
    bear_pTicks   := 0
    bear_pTime    := 0
    bear_maxLevel := 0

// â”€â”€â”€ FINAL SIGNALS (persistence-gated) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
bool sig_L1_long  = bull_persisted and bull_maxLevel >= 1
bool sig_L1_short = bear_persisted and bear_maxLevel >= 1
bool sig_L2_long  = bull_persisted and bull_maxLevel >= 2
bool sig_L2_short = bear_persisted and bear_maxLevel >= 2
bool sig_L3_long  = bull_persisted and bull_maxLevel >= 3
bool sig_L3_short = bear_persisted and bear_maxLevel >= 3

// â”€â”€â”€ UPDATE COOLDOWN (ghost-proof) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Only reset cooldown when signal PASSES persistence.
// Phantom crossovers that die â†’ zero impact on cooldown counters.
if sig_L1_long
    cd_L1l := 0
if sig_L1_short
    cd_L1s := 0
if sig_L2_long
    cd_L2l := 0
if sig_L2_short
    cd_L2s := 0
if sig_L3_long
    cd_L3l := 0
if sig_L3_short
    cd_L3s := 0

bool cross_bull_zero = ta.crossover (smc_main, 0)
bool cross_bear_zero = ta.crossunder(smc_main, 0)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PLOTTING â€” OSCILADOR  (optimizado: â‰¤40 outputs)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Zonas                                                          // 5 hline + 2 fill = 7
h0 = hline(  0,  "Cero",   color.new(color.gray, 50), linestyle=hline.style_solid,  linewidth=1)
h1 = hline( 50,  "OB",     color.new(bearCol,    70), linestyle=hline.style_dashed, linewidth=1)
h2 = hline(-50,  "OS",     color.new(bullCol,    70), linestyle=hline.style_dashed, linewidth=1)
h3 = hline( 80,  "Ext OB", color.new(bearCol,    80), linestyle=hline.style_dotted)
h4 = hline(-80,  "Ext OS", color.new(bullCol,    80), linestyle=hline.style_dotted)
fill(h1, h3, color=color.new(bearCol, 94), title="Zona OB")
fill(h2, h4, color=color.new(bullCol, 94), title="Zona OS")

// LÃ­neas principales                                             // 5 plot = 5
bool mom_rising = smc_main > nz(smc_main[1])
color hist_col = smc_main >= 0 ? (mom_rising ? bullCol : color.new(bullCol, 55)) : (mom_rising ? color.new(bearCol, 55) : bearCol)
plot(showHist ? smc_main : na, "Histograma", color=hist_col, style=plot.style_columns, linewidth=3)
color main_col = smc_main >= smc_trig ? bullCol : bearCol
plot(smc_main, "SMC Main", color=main_col, linewidth=2)
plot(showTrig ? smc_trig : na, "Trigger", color=trigCol, linewidth=1)
plot(showCapaA ? posA0 : na, "Capa A", color=color.new(color.aqua, 40), linewidth=1)
plot(showCapaB ? obP0  : na, "Capa B", color=color.new(color.orange, 40), linewidth=1)

// Background trend (1 bgcolor combinado)                         // 1 bgcolor
color trend_bg = align_bull ? color.new(bullCol, 93) : align_bear ? color.new(bearCol, 93) : na
bgcolor(trend_bg, title="Trend BG")

// Eventos en oscilador (6 plotshape)                             // 6 plotshape
plotshape(showEvOsc and htf_choch_b, "HTF Câ–²", shape.labelup,   location.bottom, color.new(bullCol, 0), text="CÂ·H", textcolor=color.white, size=size.small)
plotshape(showEvOsc and htf_choch_r, "HTF Câ–¼", shape.labeldown,  location.top,    color.new(bearCol, 0), text="CÂ·H", textcolor=color.white, size=size.small)
plotshape(showEvOsc and ev_choch_bull, "CHoCHâ–²", shape.diamond, location.bottom, color.new(bullCol, 10), size=size.tiny)
plotshape(showEvOsc and ev_choch_bear, "CHoCHâ–¼", shape.diamond, location.top,    color.new(bearCol, 10), size=size.tiny)
plotshape(showEvOsc and (ev_bos_bull or ev_sweep_dn), "BOS/Swâ–²", shape.triangleup,   location.bottom, color.new(bullCol, 30), size=size.tiny)
plotshape(showEvOsc and (ev_bos_bear or ev_sweep_up), "BOS/Swâ–¼", shape.triangledown, location.top,    color.new(bearCol, 30), size=size.tiny)

// SeÃ±ales en oscilador (4 plotshape: solo L2 y L3)              // 4 plotshape
plotshape(showL2 and sig_L2_long  and not sig_L3_long,  "L2â–²", shape.triangleup,   location.bottom, color.new(bullCol, 10), size=size.small)
plotshape(showL2 and sig_L2_short and not sig_L3_short, "L2â–¼", shape.triangledown, location.top,    color.new(bearCol, 10), size=size.small)
plotshape(showL3 and sig_L3_long,  "L3â–²", shape.labelup,   location.bottom, color.new(bullCol, 0), text="â–²", textcolor=color.white, size=size.normal)
plotshape(showL3 and sig_L3_short, "L3â–¼", shape.labeldown, location.top,    color.new(bearCol, 0), text="â–¼", textcolor=color.white, size=size.normal)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PLOTTING â€” CHART PRINCIPAL (force_overlay)                     // 8 plotshape
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// L1 en chart (triÃ¡ngulos tiny semitransparentes)
plotshape(showChart and showL1 and sig_L1_long and not sig_L2_long,
     "Chart L1â–²", shape.triangleup, location.belowbar,
     color.new(bullCol, 50), size=size.tiny, force_overlay=true)
plotshape(showChart and showL1 and sig_L1_short and not sig_L2_short,
     "Chart L1â–¼", shape.triangledown, location.abovebar,
     color.new(bearCol, 50), size=size.tiny, force_overlay=true)
// L2 en chart (triÃ¡ngulos small)
plotshape(showChart and showL2 and sig_L2_long and not sig_L3_long,
     "Chart L2â–²", shape.triangleup, location.belowbar,
     color.new(bullCol, 10), size=size.small, force_overlay=true)
plotshape(showChart and showL2 and sig_L2_short and not sig_L3_short,
     "Chart L2â–¼", shape.triangledown, location.abovebar,
     color.new(bearCol, 10), size=size.small, force_overlay=true)
// L3 en chart (labels LONG/SHORT)
plotshape(showChart and showL3 and sig_L3_long,
     "Chart L3â–²", shape.labelup, location.belowbar,
     color.new(bullCol, 0), text="LONG", textcolor=color.white, size=size.normal, force_overlay=true)
plotshape(showChart and showL3 and sig_L3_short,
     "Chart L3â–¼", shape.labeldown, location.abovebar,
     color.new(bearCol, 0), text="SHORT", textcolor=color.white, size=size.normal, force_overlay=true)
// Eventos SMC en chart (CHoCH + BOS)
plotshape(showChart and showEvOsc and (ev_choch_bull or ev_bos_bull),
     "Chart Evâ–²", shape.diamond, location.belowbar,
     color.new(bullCol, 10), size=size.tiny, force_overlay=true)
plotshape(showChart and showEvOsc and (ev_choch_bear or ev_bos_bear),
     "Chart Evâ–¼", shape.diamond, location.abovebar,
     color.new(bearCol, 10), size=size.tiny, force_overlay=true)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TABLA
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
if showTable and barstate.islast
    var table t = table.new(position.top_right, 3, 9, bgcolor=color.new(#1a1a2e, 15), border_width=1, border_color=color.new(color.gray, 70))

    table.cell(t, 0, 0, "SMCÂ·v7.4", bgcolor=color.new(#16213e, 0), text_color=color.white, text_size=size.small)
    table.cell(t, 1, 0, "TF:" + timeframe.period, bgcolor=color.new(#16213e, 0), text_color=color.gray, text_size=size.tiny)
    table.cell(t, 2, 0, htf1 + "/" + htf2, bgcolor=color.new(#16213e, 0), text_color=color.gray, text_size=size.tiny)

    string ft_badge = smc_main > smc_trig ? " â–²" : " â–¼"
    color  ft_col   = smc_main > smc_trig ? bullCol : bearCol
    table.cell(t, 0, 1, "Main", text_color=color.gray, text_size=size.small)
    table.cell(t, 1, 1, str.tostring(math.round(smc_main, 1)) + ft_badge, text_color=ft_col, text_size=size.small)
    table.cell(t, 2, 1, "T:" + str.tostring(math.round(smc_trig, 1)), text_color=color.new(color.white, 40), text_size=size.tiny)

    table.cell(t, 0, 2, "Position", text_color=color.gray, text_size=size.small)
    table.cell(t, 1, 2, str.tostring(math.round(posA0, 1)), text_color=posA0 >= 0 ? bullCol : bearCol, text_size=size.small)
    table.cell(t, 2, 2, str.tostring(math.round(wA * 100, 0)) + "%", text_color=color.gray, text_size=size.tiny)

    table.cell(t, 0, 3, "OB Prox", text_color=color.gray, text_size=size.small)
    table.cell(t, 1, 3, str.tostring(math.round(obP0, 1)), text_color=obP0 >= 0 ? bullCol : bearCol, text_size=size.small)
    table.cell(t, 2, 3, str.tostring(math.round(wB * 100, 0)) + "%", text_color=color.gray, text_size=size.tiny)

    string tr0_s = tr0 == 1 ? "â–²" : "â–¼"
    string tr1_s = htf_en ? (tr1 == 1 ? "â–²" : "â–¼") : "â€”"
    string tr2_s = htf_en and htf_mode == "2 HTFs" ? (tr2 == 1 ? "â–²" : "â–¼") : "â€”"
    string htf_str = tr0_s + " " + tr1_s + " " + tr2_s
    string aln_str = align_bull ? "  FULL BULL" : align_bear ? "  FULL BEAR" : ""
    color  htf_col = align_bull ? bullCol : align_bear ? bearCol : color.yellow
    table.cell(t, 0, 4, "Trend", text_color=color.gray, text_size=size.small)
    table.cell(t, 1, 4, htf_str + aln_str, text_color=htf_col, text_size=size.small)
    table.cell(t, 2, 4, htf_mode, text_color=color.gray, text_size=size.tiny)

    string lev = ev_choch_bull?"CHoCH â–²":ev_choch_bear?"CHoCH â–¼":ev_bos_bull?"BOS â–²":ev_bos_bear?"BOS â–¼":ev_sweep_dn?"Sweep â–¼":ev_sweep_up?"Sweep â–²":htf_choch_b?"HTF Câ–²":htf_choch_r?"HTF Câ–¼":"â€”"
    color  lec = ev_choch_bull or ev_bos_bull or ev_sweep_dn?bullCol:ev_choch_bear or ev_bos_bear or ev_sweep_up?bearCol:htf_choch_b?bullCol:htf_choch_r?bearCol:color.gray
    table.cell(t, 0, 5, "Evento", text_color=color.gray, text_size=size.small)
    table.cell(t, 1, 5, lev, text_color=lec, text_size=size.small)
    table.cell(t, 2, 5, "", text_size=size.tiny)

    string zone_str = smc_main>80?"EXTREME OB":smc_main>50?"OB":smc_main<-80?"EXTREME OS":smc_main<-50?"OS":"NEUTRAL"
    color  zone_col = smc_main>50?bearCol:smc_main<-50?bullCol:color.gray
    table.cell(t, 0, 6, "Zona", text_color=color.gray, text_size=size.small)
    table.cell(t, 1, 6, zone_str, text_color=zone_col, text_size=size.small)
    table.cell(t, 2, 6, "", text_size=size.tiny)

    // Protection status row
    string protStr = useProtBreaks ? "Breaks:âœ“" : "Breaks:â€”"
    string persStr = usePersist ? (persistMode == "Time" ? str.tostring(persistSec, "#") + "s" : str.tostring(persistTicks) + "t") : "â€”"
    string lockStr = bull_persisted ? " L" + str.tostring(bull_maxLevel) + "â–²âœ“" : bear_persisted ? " L" + str.tostring(bear_maxLevel) + "â–¼âœ“" : anyBullGated ? " â–²â³" + str.tostring(bull_pTicks) : anyBearGated ? " â–¼â³" + str.tostring(bear_pTicks) : ""
    table.cell(t, 0, 7, "Shield", text_color=color.gray, text_size=size.small)
    table.cell(t, 1, 7, protStr + "  P:" + persStr + lockStr, text_color=useProtBreaks or usePersist ? color.new(color.aqua, 20) : color.gray, text_size=size.tiny)
    table.cell(t, 2, 7, "", text_size=size.tiny)

    // Cooldown status
    int minCdBull = math.min(cd_L1l, math.min(cd_L2l, cd_L3l))
    int minCdBear = math.min(cd_L1s, math.min(cd_L2s, cd_L3s))
    string cdStr = minCdBull <= sigCool ? "â–²COOL " + str.tostring(sigCool - minCdBull) + "b" : minCdBear <= sigCool ? "â–¼COOL " + str.tostring(sigCool - minCdBear) + "b" : "READY"
    table.cell(t, 0, 8, "Cooldown", text_color=color.gray, text_size=size.small)
    table.cell(t, 1, 8, cdStr, text_color=cdStr == "READY" ? bullCol : color.yellow, text_size=size.small)
    table.cell(t, 2, 8, str.tostring(sigCool) + "b", text_color=color.gray, text_size=size.tiny)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ALERTAS (v7.4: only fire AFTER persistence passes)
// Total outputs: 7+5+1+6+4+8+6 = 37 (lÃ­mite 64)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
alertcondition(sig_L3_long,  "ğŸ”¥ L3 LONG",    "SMC v7.4 L3 LONG (persisted) | {{ticker}} @ {{close}} | {{interval}}")
alertcondition(sig_L3_short, "ğŸ”¥ L3 SHORT",   "SMC v7.4 L3 SHORT (persisted) | {{ticker}} @ {{close}} | {{interval}}")
alertcondition(sig_L2_long,  "âš¡ L2 LONG",    "SMC v7.4 L2 LONG (persisted) | {{ticker}} @ {{close}} | {{interval}}")
alertcondition(sig_L2_short, "âš¡ L2 SHORT",   "SMC v7.4 L2 SHORT (persisted) | {{ticker}} @ {{close}} | {{interval}}")

alertcondition(sig_L1_long,  "L1 LONG",    "SMC v7.4 L1 LONG (persisted) | {{ticker}} @ {{close}} | {{interval}}")
alertcondition(sig_L1_short, "L1 SHORT",   "SMC v7.4 L1 SHORT (persisted) | {{ticker}} @ {{close}} | {{interval}}")
alertcondition(htf_choch_b,  "HTF CHoCH â–²",   "SMC v7.4 CHoCH BULL HTF | {{ticker}}")
alertcondition(htf_choch_r,  "HTF CHoCH â–¼",   "SMC v7.4 CHoCH BEAR HTF | {{ticker}}")
